<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
</head>

<body>
  <h2 id="heading_id_2">17.1 Rails Concepts</h2>

  <p id="N187CF">InChapter 3, <a href="../Text/f_0026.html#chp.mvc">​<em>The Architecture of Rails Applications</em>​</a> we introduced models, views, and controllers. Now let’s see how we applied each of these concepts in the Depot application. Then let’s explore how we used configuration, testing, and deployment.</p>

  <h3 id="heading_id_3">Model</h3>

  <p id="N187E6">Models are where all of the persistent data retained by your application is managed. In developing the Depot application, we created five models: <code class="cf class">Cart</code>, <code class="cf class">LineItem</code>, <code class="cf class">Order</code>, <code class="cf class">Product</code>, and <code class="cf class">User</code>.</p>

  <p id="N187FF">By default, all models have <code class="cf ic">id</code>, <code class="cf ic">created_at</code>, and <code class="cf ic">updated_at</code> attributes. To our models, we added attributes of type <code class="cf ic">string</code> (examples: <code class="cf ic">title</code>, <code class="cf ic">name</code>), <code class="cf ic">integer</code> (<code class="cf ic">quan</code>-<code class="cf ic">tity</code>), <code class="cf ic">text</code> (<code class="cf ic">description</code>, <code class="cf ic">address</code>), <code class="cf ic">decimal</code> (<code class="cf ic">price</code>), and foreign keys (<code class="cf ic">product_id</code>, <code class="cf ic">cart_</code> <code class="cf ic">id</code>). We even created a virtual attribute that is never stored in the database, namely, a <code class="cf ic">password</code>.</p>

  <p id="N18837">We created <code class="cf ic">has_many</code> and <code class="cf ic">belongs_to</code> relationships that we can use to navigate between our model objects, such as from <code class="cf class">Carts</code> to <code class="cf class">LineItems</code> to <code class="cf class">Products</code>.</p>

  <p id="N18849">We employed migrations to update the databases, not only to introduce new schema information but also to modify existing data. We demonstrated that they can be applied in a fully reversible manner.</p>

  <p id="N1884C">The models we created were not merely passive receptacles for our data. For starters, they actively validate the data, preventing errors from propagating. We created validations for presence, inclusion, numericality, range, uniqueness, format, and confirmation. (And length too, if you completed the exercises). We created custom validations for ensuring that deleted products are not referenced by any line item. We used an Active Record hook to ensure that an administrator always remains and a transaction to roll back incomplete updates on failure.</p>

  <p id="N1884F">We also created logic to add a product to a cart, add all line items from a cart to an order, encrypt and authenticate a password, and compute various totals.</p>

  <p id="N18852">Finally, we created a default sort order for products for display purposes.</p>

  <h3 id="heading_id_4">View</h3>

  <p id="N18859">Views control the way our application presents itself to the external world. By default, Rails scaffolding provides <code class="cf ic">edit</code>, <code class="cf ic">index</code>, <code class="cf ic">new</code>, and <code class="cf ic">show</code>, as well as a partial named <code class="cf ic">form</code> that is shared between <code class="cf ic">edit</code> and <code class="cf ic">new</code>. We modified a number of these, as well as creating new partials for carts and line items.</p>

  <p id="N18878">In addition to the model backed resource views, we created entirely new views for <code class="cf ic">admin</code>, <code class="cf ic">sessions</code>, and the <code class="cf ic">store</code> itself.</p>

  <p id="N18884">We updated an overall layout to establish a common look and feel for the entire site. We linked in a stylesheet. We made use of templates to generate JavaScript that takes advantage of Web 2.0 technologies to make our website more interactive.</p>

  <p id="N18887">We made use of a helper to determine when to hide the cart from the main view.</p>

  <p id="N1888A">We localized the customer views for display both in English and in Spanish.</p>

  <p id="N1888D">While we focused primarily on HTML views, we also created plain-text views and Atom views. Not all of the views were designed for browsers: we created views for email too, and those views were able to share partials for displaying line items.</p>

  <h3 id="heading_id_5">Controller</h3>

  <p id="N18894">By the time we were done, we created eight controllers: one each for the five models and the three additional ones in order to support the views for <code class="cf ic">admin</code>, <code class="cf ic">sessions</code>, and the <code class="cf ic">store</code> itself.</p>

  <p id="N188A7">These controllers interacted with the models in a number of ways: from finding and fetching data and putting it into instance variables to updating models and saving data entered via forms. When done, we either redirected to another action or rendered a view. We rendered views in HTML, JSON, and Atom.</p>

  <p id="N188AA">We created filters that were run before selected actions to authorize requests. We placed logic common to a number of controllers into the common base class for all controllers, namely, <code class="cf class">ApplicationController</code>.</p>

  <p id="N188B0">We managed sessions, keeping track of the logged-in user (for administrators) and carts (for customers). We kept track of the current locale used for internationalization of our output. We captured errors, logged them, and informed the user via notices. We paginated orders through the use of the <code class="cf ic">will_paginate</code> plugin.</p>

  <p id="N188B6">We also sent confirmation emails on receipt of an order.</p>

  <h3 id="heading_id_6">Configuration</h3>

  <p id="N188CB">While conventions keep to a minimum the amount of configuration required for a Rails application, we did do a bit of customization.</p>

  <p id="N188D5">We modified our database configuration in order to use MySQL in production.</p>

  <p id="N188D8">We defined routes for our resources, our admin and session controllers, and the <span class="emph">root</span> of our website, namely, our storefront. We defined a <code class="cf ic">who_bought</code> member of our <code class="cf ic">products</code> resource in order to access Atom feeds that contain this information.</p>

  <p id="N188E4">We created an initializer for i18n purposes and updated the locales information for both English (en) and Spanish (es).</p>

  <p id="N188E7">We created seed data for our database.</p>

  <p id="N188EA">We created a Capistrano script for deployment, including the definition of a few custom tasks.</p>

  <h3 id="heading_id_7">Testing</h3>

  <p id="N188F1">We maintained and enhanced tests throughout.</p>

  <p id="N188FB">We employed unit tests to validation methods. We also tested increasing the quantity on a given line item.</p>

  <p id="N188FE">Rails provided basic tests for all our scaffolded controllers, which we maintained as we made changes. We added tests along the way for things such as Ajax and ensuring that a cart has items before we create an order.</p>

  <p id="N18901">We used fixtures to provide test data to fuel our tests.</p>

  <p id="N18904">Finally, we created an integration test to test an end-to-end scenario involving a user adding a product to a cart, entering an order, and receiving a confirmation email.</p>

  <table class="figure" id="fig.rdoc">
    <tr>
      <td><img alt="images/depot_r_rdoc.png" src="../Images/depot_r_rdoc.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 42. Our application’s internal documentation</b>
      </td>
    </tr>
  </table>

  <h3 id="heading_id_8">Deployment</h3>

  <p id="N18914">We deployed our application to a production-quality web server (Apache httpd) using a production-quality database server (MySQL). Along the way, we installed and configured Phusion Passenger to run our application, Bundler to track dependencies, and Git to configuration manage our code. Capistrano was employed to orchestrate updating the deployed web server in production from our development machine.</p>

  <p id="N18917">We made use of <code class="cf ic">test</code> and <code class="cf ic">production</code> environments to prevent our experimentation during development from affecting production. Our development environment made use of the lightweight SQLite database server and a lightweight web server, most likely WEBrick. Our tests were run in a controlled environment with test data provided by fixtures.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
