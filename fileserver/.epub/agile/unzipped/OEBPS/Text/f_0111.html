<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">20.3 Objects and Operations That Span Requests</h2>

  <p id="N1BEAA">While the bulk of the state that persists across requests belongs in the database and is accessed via Active Record, some other bits of state have different life spans and need to be managed differently. In the Depot application, while the Cart itself was stored in the database, knowledge of which cart is the current cart was managed by sessions. Flash notices were used to communicate simple messages such as “Can’t delete the last user” to the next request after a redirect. And filters were used to extract locale data from the URLs themselves.</p>

  <p id="N1BEAD">In this section, we will explore each of these mechanisms in turn.</p>

  <h3 id="sec.sessions">Rails Sessions</h3>

  <p id="N1BEB5">A Rails session is a hash-like structure that persists across requests. Unlike raw cookies, sessions can hold any objects (as long as those objects can be marshaled), which makes them ideal for holding state information in web applications. For example, in our store application, we used a session to hold the shopping cart object between requests. The <code class="cf class">Cart</code> object could be used in our application just like any other object. But Rails arranged things such that the cart was saved at the end of handling each request and, more important, that the correct cart for an incoming request was restored when Rails started to handle that request. Using sessions, we can pretend that our application stays around between requests.</p>

  <p id="N1BEC4">And that leads to an interesting question: exactly where does this data stay around between requests? One choice is for the server to send it down to the client as a cookie. This is the default for Rails 3.1. It places limitations on the size and increases the bandwidth but means that there is less for the server to manage and clean up. Note that the contents are cryptographically signed but (by default) unencrypted, which means that users can see but not tamper with the contents.</p>

  <div class="xxxsays">
    <div class="heading">
      <div class="persons-picture"><img alt="David says:" src="../Images/David.png" /></div>

      <div class="label">
        David says:
      </div>

      <div class="title">
        The Wonders of a Cookie-Based Session
      </div>
    </div>

    <div class="body">
      <p id="N1BED1">The default Rails session store sounds like a crazy idea when you hear it at first. You’re going to actually store the values on the client?! But what if I want to store the nuclear launch codes in the session and I can’t have the client actually knowing those?</p>

      <p id="N1BEDD">Yes, the default store is not suitable for storing secrets you need to keep from the client. But that’s actually a valuable constraint that’ll lead you to avoid the perils of keeping complex objects that can go out of date in the session. And the paper dragon of the nuclear launch codes is just about never a real, relevant concern.</p>

      <p id="N1BEE0">Neither is the size constraint. Cookies can be only about 4KB big, so you can’t stuff them with all sorts of malarkey. That again fits the best practices of storing only references, like a <code class="cf ic">cart_id</code>, not the actual cart itself.</p>

      <p id="N1BEE6">The key security concern you should be worried about is whether the client is actually able to change the session. You want to ensure the integrity of the values that you put. It’d be no good if the client could change his <code class="cf ic">cart_id</code> from a 5 to 8 and get someone else’s cart. Thankfully, Rails protects you against exactly this case by signing the session and raising an exception that warns of the tampering if it doesn’t match.</p>

      <p id="N1BEEC">The benefits you get back is that there is no load on the database from fetching and saving the session on every request, and there are no cleanup duties either. If you keep your session on the filesystem or in the database, you’ll have to deal with how to clean up stale sessions, which is a real hassle. No one likes to be on cleanup duty. The cookie-based sessions know how to clean up after themselves. What’s not to love about that?</p>
    </div>
  </div>

  <p id="N1BEEF">The other option is to store the data on the server. There are two parts to this. First, Rails has to keep track of sessions. It does this by creating (by default) a 32-hex character key (which means there are 16<sup>32</sup> possible combinations). This key is called the <span class="firstuseinline">session id</span>, and it’s effectively random. Rails arranges to store this session id as a cookie (with the key <code class="cf ic">_session_id</code>) on the user’s browser. Because subsequent requests come into the application from this browser, Rails can recover the session id.</p>

  <p id="N1BEFC">Second, Rails keeps a persistent store of session data on the server, indexed by the session id. When a request comes in, Rails looks up the data store using the session id. The data that it finds there is a serialized Ruby object. It deserializes this and stores the result in the controller’s <code class="cf ic">session</code> attribute, where the data is available to our application code. The application can add to and modify this data to its heart’s content. When it finishes processing each request, Rails writes the session data back into the data store. There it sits until the next request from this browser comes along.</p>

  <p id="N1BF17">What should you store in a session? You can store anything you want, subject to a few restrictions and caveats:</p>

  <ul>
    <li>
      <p id="N1BF1D">There are some restrictions on what kinds of object you can store in a session. The details depend on the storage mechanism you choose (which we’ll look at shortly). In the general case, objects in a session must be serializable (using Ruby’s <code class="cf class">Marshal</code> functions). This means, for example, that you cannot store an I/O object in a session.</p>
    </li>

    <li>
      <p id="N1BF28">If you store any Rails model objects in a session, you’ll have to add <code class="cf ic">model</code> declarations for them. This causes Rails to preload the model class so that its definition is available when Ruby comes to deserialize it from the session store. If the use of the session is restricted to just one controller, this declaration can go at the top of that controller.</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> BlogController &lt; ApplicationController</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">model :user_preferences</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="comment"># . . .</em></code></td>
        </tr>
      </table>

      <p id="N1BF5E">However, if the session might get read by another controller (which is likely in any application with multiple controllers), you’ll probably want to add the declaration to <code class="cf filename">application_controller.rb</code> in <code class="cf dir">app/controllers</code>.</p>
    </li>

    <li>
      <p id="N1BF68">You probably don’t want to store massive objects in session data&mdash;put them in the database, and reference them from the session. This is particularly true for cookie-based sessions, where the overall limit is 4KB.</p>
    </li>

    <li>
      <p id="N1BF6C">You probably don’t want to store volatile objects in session data. For example, you might want to keep a tally of the number of articles in a blog and store that in the session for performance reasons. But, if you do that, the count won’t get updated if some other user adds an article.</p>

      <p id="N1BF6F">It is tempting to store objects representing the currently logged-in user in session data. This might not be wise if your application needs to be able to invalidate users. Even if a user is disabled in the database, their session data will still reflect a valid status.</p>

      <p id="N1BF72">Store volatile data in the database, and reference it from the session instead.</p>
    </li>

    <li>
      <p id="N1BF76">You probably don’t want to store critical information solely in session data. For example, if your application generates an order confirmation number in one request and stores it in session data so that it can be saved to the database when the next request is handled, you risk losing that number if the user deletes the cookie from their browser. Critical information needs to be in the database.</p>
    </li>
  </ul>

  <p id="N1BF79">There’s one more caveat, and it’s a big one. If you store an object in session data, then the next time you come back to that browser, your application will end up retrieving that object. However, if in the meantime you’ve updated your application, the object in session data may not agree with the definition of that object’s class in your application, and the application will fail while processing the request. There are three options here. One is to store the object in the database using conventional models and keep just the id of the row in the session. Model objects are far more forgiving of schema changes than the Ruby marshaling library. The second option is to manually delete all the session data stored on your server whenever you change the definition of a class stored in that data.</p>

  <p id="N1BF7C">The third option is slightly more complex. If you add a version number to your session keys and change that number whenever you update the stored data, you’ll only ever load data that corresponds with the current version of the application. You can potentially version the classes whose objects are stored in the session and use the appropriate classes depending on the session keys associated with each request. This last idea can be a lot of work, so you’ll need to decide whether it’s worth the effort.</p>

  <p id="N1BF7F">Because the session store is hash-like, you can save multiple objects in it, each with its own key.</p>

  <p id="N1BF82">There is no need to also disable sessions for particular actions. Because sessions are lazily loaded, simply don’t reference a session in any action in which you don’t need a session.</p>

  <h4 id="sec.session.storage">Session Storage</h4>

  <p id="N1BF8A">Rails has a number of options when it comes to storing your session data. Each has good and bad points. We’ll start by listing the options and then compare them at the end.</p>

  <p id="N1BF94">The <code class="cf ic">session_store</code> attribute of <code class="cf class">ActionController::Base</code> determines the session storage mechanism&mdash;set this attribute to a class that implements the storage strategy. This class must be defined in the <code class="cf class">ActiveSupport::Cache::Store</code> module. You use symbols to name the session storage strategy; the symbol is converted into a CamelCase class name.</p>

  <dl>
    <dt class="force-newline"><code class="cf ic">session_store = :cookie_store</code></dt>

    <dd>
      <p id="N1BFA7">This is the default session storage mechanism used by Rails, starting with version 2.0. This format represents objects in their marshaled form, which allows any serializable data to be stored in sessions but is limited to 4KB total. This is the option we used in the Depot application.</p>
    </dd>

    <dt class="force-newline" id="p.session.ar"><code class="cf ic">session_store = :active_record_store</code></dt>

    <dd>
      <p id="N1BFB1">You can store your session data in your application’s database using <code class="cf class">ActiveRecordStore</code>. You can generate a migration that creates the <code class="cf sqltable">sessions</code> table using Rake:</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rake db:sessions:create</strong></code></td>
        </tr>
      </table>

      <p id="N1BFC8">Run <code class="cf commandname">rake db:migrate</code> to create the actual table.</p>

      <p id="N1BFCE">If you look at the migration file, you’ll see that Rails creates an index on the <code class="cf sqlcolumn">session_id</code> column, because it is used to look up session data. Rails also defines a column called <code class="cf sqlcolumn">updated_at</code>, so Active Record will automatically timestamp the rows in the session table&mdash;we’ll see later why this is a good idea.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">session_store = :drb_store</code></dt>

    <dd>
      <p id="N1BFDD">DRb is a protocol that allows Ruby processes to share objects over a network connection. Using the DRbStore database manager, Rails stores session data on a DRb server (which you manage outside the web application). Multiple instances of your application, potentially running on distributed servers, can access the same DRb store. DRb uses <code class="cf class">Marshal</code> to serialize objects.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">session_store = :mem_cache_store</code></dt>

    <dd>
      <p id="N1BFE9"><code class="cf ic">memcached</code> is a freely available, distributed object caching system maintained by Dormando.<a href="#FOOTNOTE-43" id="FNPTR-43">[43]</a> The Rails MemCacheStore uses Michael Granger’s Ruby interface<a href="#FOOTNOTE-44" id="FNPTR-44">[44]</a> to <code class="cf ic">memcached</code> to store sessions. <code class="cf ic">memcached</code> is more complex to use than the other alternatives and is probably interesting only if you are already using it for other reasons at your site.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">session_store = :memory_store</code></dt>

    <dd>
      <p id="N1C007">This option stores the session data locally in the application’s memory. Because no serialization is involved, any object can be stored in an in-memory session. As we’ll see in a minute, this generally is not a good idea for Rails applications.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">session_store = :file_store</code></dt>

    <dd>
      <p id="N1C010">Session data is stored in flat files. It’s pretty much useless for Rails applications, because the contents must be strings. This mechanism supports the additional configuration options <code class="cf ic">:prefix</code>, <code class="cf ic">:suffix</code>, and <code class="cf ic">:tmpdir</code>.</p>
    </dd>
  </dl>

  <h4 id="heading_id_3">Comparing Session Storage Options</h4>

  <p id="N1C020">With all these session options to choose from, which should you use in your application? As always, the answer is “It depends.”</p>

  <p id="N1C023">There are few absolutes when it comes to performance, and everyone’s context is different. Your hardware, network latencies, database choices, and possibly even the weather will impact how all the components of session storage interact. Our best advice is to start with the simplest workable solution and then monitor it. If it starts to slow you down, find out why before jumping out of the frying pan.</p>

  <p id="N1C026">If you’re a high-volume site, keeping the size of the session data small and going with <code class="cf ic">cookie_store</code> is the way to go.</p>

  <p id="N1C02C">If we rule out memory store as being too simplistic, file store as too restrictive, and <code class="cf ic">memcached</code> as overkill, the server-side choices boil down to PStore, Active Record store, and DRb-based storage. Should you need to store more in a session than you can with cookies, we recommend you start with an Active Record solution. If, as your application grows, you find this becoming a bottleneck, you can migrate to a DRb-based solution.</p>

  <h4 id="heading_id_4">Session Expiry and Cleanup</h4>

  <p id="N1C03D">One problem with all the server-side session storage solutions is that each new session adds something to the session store. This means you’ll eventually need to do some housekeeping or you’ll run out of server resources.</p>

  <p id="N1C046">There’s another reason to tidy up sessions. Many applications don’t want a session to last forever. Once a user has logged in from a particular browser, the application might want to enforce a rule that the user stays logged in only as long as they are active; when they log out or some fixed time after they last use the application, their session should be terminated.</p>

  <p id="N1C049">You can sometimes achieve this effect by expiring the cookie holding the session id. However, this is open to end-user abuse. Worse, it is hard to synchronize the expiry of a cookie on the browser with the tidying up of the session data on the server.</p>

  <p id="N1C04C">We therefore suggest that you expire sessions by simply removing their server-side session data. Should a browser request subsequently arrive containing a session id for data that has been deleted, the application will receive no session data; the session will effectively not be there.</p>

  <p id="N1C04F">Implementing this expiration depends on the storage mechanism being used.</p>

  <p id="N1C052">For PStore-based sessions, the easiest approach is to run a sweeper task periodically (for example using <code class="cf ic">cron(1)</code> under Unix-like systems). This task should inspect the last modification times of the files in the session data directory, deleting those older than a given time.</p>

  <p id="N1C058">For Active Record--based session storage, use the <code class="cf sqlcolumn">updated_at</code> columns in the <code class="cf sqltable">sessions</code> table. You can delete all sessions that have not been modified in the last hour (ignoring daylight saving time changes) by having your sweeper task issue SQL such as this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">delete</strong> <strong class="prompt">from</strong> sessions</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">where</strong> now() - updated_at &gt; 3600;</code></td>
    </tr>
  </table>

  <p id="N1C077">For DRb-based solutions, expiry takes place within the DRb server process. You’ll probably want to record timestamps alongside the entries in the session data hash. You can run a separate thread (or even a separate process) that periodically deletes the entries in this hash.</p>

  <p id="N1C07A">In all cases, your application can help this process by calling <code class="cf methodname">reset_session</code> to delete sessions when they are no longer needed (for example, when a user logs out).</p>

  <h3 id="heading_id_5">Flash: Communicating Between Actions</h3>

  <p id="N1C089">When we use <code class="cf methodname">redirect_to</code> to transfer control to another action, the browser generates a separate request to invoke that action. That request will be handled by our application in a fresh instance of a controller object&mdash;instance variables that were set in the original action are not available to the code handling the redirected action. But sometimes we need to communicate between these two instances. We can do this using a facility called the <span class="emph">flash</span>.</p>

  <p id="N1C092">The flash is a temporary scratchpad for values. It is organized like a hash and stored in the session data, so you can store values associated with keys and later retrieve them. It has one special property. By default, values stored into the flash during the processing of a request will be available during the processing of the immediately following request. Once that second request has been processed, those values are removed from the flash.</p>

  <p id="N1C09E">Probably the most common use of the flash is to pass error and informational strings from one action to the next. The intent here is that the first action notices some condition, creates a message describing that condition, and redirects to a separate action. By storing the message in the flash, the second action is able to access the message text and use it in a view.</p>

  <p id="N1C0A7">It is sometimes convenient to use the flash as a way of passing messages into a template in the current action. For example, our <code class="cf methodname">display</code> method might want to output a cheery banner if there isn’t another, more pressing note. It doesn’t need that message to be passed to the next action&mdash;it’s for use in the current request only. To do this, it could use <code class="cf ic">flash.now</code>, which updates the flash but does not add to the session data.</p>

  <p id="N1C0B0">While <code class="cf ic">flash.now</code> creates a transient flash entry, <code class="cf ic">flash.keep</code> does the opposite, making entries that are currently in the flash stick around for another request cycle. If you pass no parameters to <code class="cf ic">flash.keep</code>, then all the flash contents are preserved.</p>

  <p id="N1C0BC">Flashes can store more than just text messages&mdash;you can use them to pass all kinds of information between actions. Obviously, for longer-term information you’d want to use the session (probably in conjunction with your database) to store the data, but the flash is great if you want to pass parameters from one request to the next.</p>

  <p id="N1C0BF">Because the flash data is stored in the session, all the usual rules apply. In particular, every object must be serializable. We strongly recommend passing only simple objects in the flash.</p>

  <h3 id="sec.filter">Filters</h3>

  <p id="N1C0C7">Filters enable you to write code in your controllers that wrap the processing performed by actions&mdash;you can write a chunk of code once and have it be called before or after any number of actions in your controller (or your controller’s subclasses). This turns out to be a powerful facility. Using filters, we can implement authentication schemes, logging, response compression, and even response customization.</p>

  <p id="N1C0D5">Rails supports three types of filter: before, after, and around. Filters are called just prior to and/or just after the execution of actions. Depending on how you define them, they either run as methods inside the controller or are passed the controller object when they are run. Either way, they get access to details of the request and response objects, along with the other controller attributes.</p>

  <h4 id="heading_id_6">Before and After Filters</h4>

  <p id="N1C0DC">As their names suggest, before and after filters are invoked before or after an action. Rails maintains two chains of filters for each controller. When a controller is about to run an action, it executes all the filters on the before chain. It executes the action before running the filters on the after chain.</p>

  <p id="N1C0FC">Filters can be passive, monitoring activity performed by a controller. They can also take a more active part in request handling. If a before filter returns <code class="cf constant">false</code>, processing of the filter chain terminates, and the action is not run. A filter may also render output or redirect requests, in which case the original action never gets invoked.</p>

  <p id="N1C102">We saw an example of using filters for authorization in the administration part of our store example <a href="../Text/f_0083.html#sec.limit.access">​here​</a>. We defined an authorization method that redirected to a login screen if the current session didn’t have a logged-in user. We then made this method a before filter for all the actions in the administration controller.</p>

  <p id="N1C108">Filter declarations also accept blocks and the names of classes. If a block is specified, it will be called with the current controller as a parameter. If a class is given, its <code class="cf methodname">filter</code> class method will be called with the controller as a parameter.</p>

  <p id="N1C113">By default, filters apply to all actions in a controller (and any subclasses of that controller). You can modify this with the <code class="cf ic">:only</code> option, which takes one or more actions to be filtered, and the <code class="cf ic">:except</code> option, which lists actions to be excluded from filtering.</p>

  <p id="N1C178">The <code class="cf ic">before_filter</code> and <code class="cf ic">after_filter</code> declarations append to the controller’s chain of filters. Use the variants <code class="cf methodname">prepend_before_filter</code> and <code class="cf methodname">prepend_after_filter</code> to put filters at the front of the chain.</p>

  <p id="N1C195">After filters can be used to modify the outbound response, changing the headers and content if required. Some applications use this technique to perform global replacements in the content generated by the controller’s templates (for example, substituting a customer’s name for the string <code class="cf xmltag">&lt;customer/&gt;</code> in the response body). Another use might be compressing the response if the user’s browser supports it.</p>

  <p id="N1C19F">Around filters wrap the execution of actions. You can write an around filter in two different styles. In the first, the filter is a single chunk of code. That code is called before the action is executed. If the filter code invokes <code class="cf ic">yield</code>, the action is executed. When the action completes, the filter code continues executing.</p>

  <p id="N1C1A9">Thus, the code before the <code class="cf ic">yield</code> is like a before filter, and the code after the <code class="cf ic">yield</code> is the after filter. If the filter code never invokes <code class="cf ic">yield</code>, the action is not run&mdash;this is the same as having a before filter return <code class="cf ic">false</code>.</p>

  <p id="N1C1B8">The benefit of around filters is that they can retain context across the invocation of the action.</p>

  <p id="N1C1BB">As well as passing <code class="cf ic">around_filter</code> the name of a method, you can pass it a block or a filter class.</p>

  <p id="N1C1C1">If you use a block as a filter, it will be passed two parameters: the controller object and a proxy for the action. Use <code class="cf methodname">call</code> on this second parameter to invoke the original action.</p>

  <p id="N1C1C7">A second form allows you to pass an object as a filter. This object should implement a method called <code class="cf methodname">filter</code>. This method will be passed the controller object. It yields to invoke the action.</p>

  <p id="N1C1CD">Like before and after filters, around filters take <code class="cf ic">:only</code> and <code class="cf ic">:except</code> parameters.</p>

  <p id="N1C1D6">Around filters are (by default) added to the filter chain differently: the first around filter added executes first. Subsequently added around filters will be nested within existing around filters.</p>

  <h4 id="heading_id_7">Filter Inheritance</h4>

  <p id="N1C1E1">If you subclass a controller containing filters, the filters will be run on the child objects as well as in the parent. However, filters defined in the children will not run in the parent.</p>

  <p id="N1C1E4">If you don’t want a particular filter to run in a child controller, you can override the default processing with the <code class="cf ic">skip_before_filter</code> and <code class="cf ic">skip_after_filter</code> declarations. These accept the <code class="cf ic">:only</code> and <code class="cf ic">:except</code> parameters.</p>

  <p id="N1C1F9">You can use <code class="cf ic">skip_filter</code> to skip any filter (before, after, and around). However, it works only for filters that were specified as the (symbol) name of a method.</p>

  <p id="N1C1FF">We made use of <code class="cf ic">skip_before_filter</code> in Section 14.3, <a href="../Text/f_0083.html#sec.limit.access">​<em>Iteration I3: Limiting Access</em>​</a>.</p>

  <h3 id="heading_id_8">What We Just Did</h3>

  <p id="N1C216">We learned how Action Dispatch and Action Controller cooperate to enable our server to respond to requests. The importance of this can’t be emphasized enough. In nearly every application, this is the primary place where the creativity of your application is expressed. While Active Record and Action View are hardly passive, our routes and our controllers are the place where the action is.</p>

  <p id="N1C219">We started this chapter by covering the concept of REST, which was the inspiration for the way in which Rails approaches routing of requests. We saw how this provided seven basic actions as a starting point and how to add more actions. We also saw how to select a data representation (for example, JSON or XML). And we covered how to test routes.</p>

  <p id="N1C21C">We then covered the environment that Action Controller provides for your actions, as well as the methods it provides for rendering and redirecting. Finally, we covered sessions, flash, and filters, each of which is available for use in your application’s controllers.</p>

  <p id="N1C21F">Along the way, we showed how each of these concepts were used in the Depot application. Now that you have seen each in use and have been exposed to the theory behind each, how you combine and use these concepts is limited only by your own creativity.</p>

  <p id="N1C222">In the next chapter, we will cover the remaining component of Action Pack, namely, Action View, which handles the rendering of results.</p>

  <div class="footnotes">
    <h4 id="heading_id_9">Footnotes</h4>

    <table cellspacing="3">
      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0109.html#FNPTR-42" id="FOOTNOTE-42">[42]</a></td>

        <td>
          <p id="N1AA59"><a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="#FNPTR-43" id="FOOTNOTE-43">[43]</a></td>

        <td>
          <p id="N1BFEF"><a href="http://memcached.org/">http://memcached.org/</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="#FNPTR-44" id="FOOTNOTE-44">[44]</a></td>

        <td>
          <p id="N1BFF5">Available from <a href="http://deveiate.org/projects/RMemCache">http://deveiate.org/projects/RMemCache</a></p>
        </td>
      </tr>
    </table>
  </div>

  <div class="copyright">
    Copyright © 2011, The Pragmatic Bookshelf.
  </div><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
