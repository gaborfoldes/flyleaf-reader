<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.hello.rails">2.2 Hello, Rails!</h2>

  <p id="N10968">We can’t help it&mdash;we just have to write a “Hello, World!” program to try a new system. Let’s start by creating a simple application that sends our cheery greeting to a browser. After we get that working, we will embellish it with the current time and links.</p>

  <p id="N1096B">As we’ll explore further in Chapter 3, <a href="../Text/f_0026.html#chp.mvc">​<em>The Architecture of Rails Applications</em>​</a>, Rails is a Model-View-Controller framework. Rails accepts incoming requests from a browser, decodes the request to find a controller, and calls an action method in that controller. The controller then invokes a particular view to display the results to the user. The good news is that Rails takes care of most of the internal plumbing that links all these actions. To write our simple “Hello, World!” application, we need code for a controller and a view, and we need a route to connect the two. We don’t need code for a model, because we’re not dealing with any data. Let’s start with the controller.</p>

  <p id="N10977">In the same way that we used the <code class="cf commandname">rails</code> command to create a new Rails application, we can also use a generator script to create a new controller for our project. This command is called <code class="cf commandname">rails generate</code>. So, to create a controller called <code class="cf ic">say</code>, we make sure we’re in the <code class="cf dir">demo</code> directory and run the command, passing in the name of the controller we want to create and the names of the actions we intend for this controller to support:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">demo&gt; <strong class="prompt">rails generate controller Say hello goodbye</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/controllers/say_controller.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">route get "say/goodbye"</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">route get "say/hello"</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke erb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/views/say</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/views/say/hello.html.erb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/views/say/goodbye.html.erb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke test_unit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create test/functional/say_controller_test.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke helper</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/helpers/say_helper.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke test_unit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create test/unit/helpers/say_helper_test.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke assets</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke coffee</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/assets/javascripts/say.js.coffee</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">invoke scss</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create app/assets/stylesheets/say.css.scss</code></td>
    </tr>
  </table>

  <p id="N109D7">The <code class="cf ic">rails generate</code> command logs the files and directories it examines, noting when it adds new Ruby scripts or directories to your application. For now, we’re interested in one of these scripts and (in a minute) the <code class="cf fileextension">html.erb</code> files.</p>

  <p id="N109E0">The first source file we’ll be looking at is the controller. You’ll find it in the file <code class="cf filename">app/controllers/say_controller.rb</code>. Let’s take a look at it:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/work/demo1/app/controllers/say_controller.rb">rails31/work/demo1/app/controllers/say_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> SayController &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> hello</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> goodbye</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N10A15">Pretty minimal, eh? <code class="cf class">SayController</code> is a class that inherits from <code class="cf class">ApplicationController</code>, so it automatically gets all the default controller behavior. What does this code have to do? For now, it does nothing&mdash;we simply have an empty action method named <code class="cf ic">hello</code>. To understand why this method is named this way, we need to look at the way Rails handles requests.</p>

  <h3 id="heading_id_2">Rails and Request URLs</h3>

  <p id="N10A2B">Like any other web application, a Rails application appears to its users to be associated with a URL. When you point your browser at that URL, you are talking to the application code, which generates a response to you.</p>

  <p id="N10A3A">Let’s try it now. Navigate to the URL <a href="http://localhost:3000/say/hello">http://localhost:3000/say/hello</a> in a browser window. (Note that in the development environment we don’t have any application string at the front of the path&mdash;we route directly to the controller.) You’ll see something that looks like Figure 2, <a href="#fig.template.missing">​<em>Template ready for us to fill in</em>​</a>.</p>

  <table class="figure" id="fig.template.missing">
    <tr>
      <td><img alt="images/template_missing.png" src="../Images/template_missing.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 2. Template ready for us to fill in</b>
      </td>
    </tr>
  </table>

  <h3 id="heading_id_3">Our First Action</h3>

  <p id="N10A50">At this point, we can see not only that have we connected the URL to our controller but also that Rails is pointing the way to our next step, namely, to tell Rails what to display. That’s where views come in. Remember when we ran the script to create the new controller? That command added six files and a new directory to our application. That directory contains the template files for the controller’s views. In our case, we created a controller named <code class="cf ic">say</code>, so the views will be in the directory <code class="cf dir">app/views/say</code>.</p>

  <p id="N10A59">By default, Rails looks for templates in a file with the same name as the action it’s handling. In our case, that means we need to replace a file called <code class="cf filename">hello.html.erb</code> in the directory <code class="cf dir">app/views/say</code>. (Why <code class="cf fileextension">html.erb</code>? We’ll explain in a minute.) For now, let’s just put some basic HTML in there:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/work/demo1/app/views/say/hello.html.erb">rails31/work/demo1/app/views/say/hello.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h1&gt;</strong>Hello from Rails!<strong class="prompt">&lt;/h1&gt;</strong></code></td>
    </tr>
  </table>

  <p id="N10A81">Save the file <code class="cf filename">hello.html.erb</code>, and refresh your browser window. You should see it display our friendly greeting:</p>

  <div xmlns:str="http://exslt.org/strings"><img alt="images/hello1.png" src="../Images/hello1.png" /></div>

  <p id="N10A8A">In total, we’ve looked at two files in our Rails application tree. We looked at the controller, and we modified a template to display a page in the browser. These files live in standard locations in the Rails hierarchy: controllers go into <code class="cf dir">app/controllers</code>, and views go into subdirectories of <code class="cf dir">app/views</code>. See Figure 3, <a href="#fig.demo.files">​<em>Standard locations for controllers and views</em>​</a>.</p>

  <table class="figure" id="fig.demo.files">
    <tr>
      <td><img alt="images/demo_files.png" src="../Images/demo_files.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 3. Standard locations for controllers and views</b>
      </td>
    </tr>
  </table>

  <h3 id="heading_id_4">Making It Dynamic</h3>

  <p id="N10AAD">So far, our Rails application is pretty boring&mdash;it just displays a static page. To make it more dynamic, let’s have it show the current time each time it displays the page.</p>

  <p id="N10AB0">To do this, we need to make a change to the template file in the view&mdash;it now needs to include the time as a string. That raises two questions. First, how do we add dynamic content to a template? Second, where do we get the time from?</p>

  <h4 id="sec.erb">Dynamic Content</h4>

  <p id="N10AB8">There are many ways of creating dynamic templates in Rails. The most common way, which we’ll use here, is to embed Ruby code in the template itself. That’s why we named our template file <code class="cf filename">hello.html.erb</code>; the <code class="cf fileextension">html.erb</code> suffix tells Rails to expand the content in the file using a system called ERB.</p>

  <p id="N10ACE"><code class="cf ic">ERB</code> is a filter that is installed as part of the Rails installation that takes an <code class="cf fileextension">erb</code> file and outputs a transformed version. The output file is often HTML in Rails, but it can be anything. Normal content is passed through without being changed. However, content between <code class="cf ic">&lt;%=</code> and <code class="cf ic">%&gt;</code> is interpreted as Ruby code and executed. The result of that execution is converted into a string, and that value is substituted in the file in place of the <code class="cf ic">&lt;%=</code>…<code class="cf ic">%&gt;</code> sequence. For example, change <code class="cf filename">hello.html.erb</code> to display the current time:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/work/demo2/app/views/say/hello.html.erb">rails31/work/demo2/app/views/say/hello.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h1&gt;</strong>Hello from Rails!<strong class="prompt">&lt;/h1&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;p&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1">It is now &lt;%= Time.now %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/p&gt;</strong></code></td>
    </tr>
  </table>

  <p id="N10B0D">When we refresh our browser window, we see the time displayed using Ruby’s standard format:<a href="../Text/f_0025.html#FOOTNOTE-14" id="FNPTR-14">[14]</a></p>

  <div xmlns:str="http://exslt.org/strings"><img alt="images/hello2.png" src="../Images/hello2.png" /></div>

  <p id="N10B1F">Notice that if you hit Refresh in your browser, the time updates each time the page is displayed. It looks as if we’re really generating dynamic content.</p>

  <div class="sidebar">
    <div class="sidebar-title">
      Making Development Easier
    </div>

    <div class="sidebar-content">
      <p id="N10B25">You might have noticed something about the development we’ve been doing so far. As we’ve been adding code to our application, we haven’t had to restart the running application. It has been happily chugging away in the background. And yet each change we make is available whenever we access the application through a browser. What gives?</p>

      <p id="N10B28">It turns out that the Rails dispatcher is pretty clever. In development mode (as opposed to testing or production), it automatically reloads application source files when a new request comes along. That way, when we edit our application, the dispatcher makes sure it’s running the most recent changes. This is great for development.</p>

      <p id="N10B3B">However, this flexibility comes at a cost&mdash;it causes a short pause after you enter a URL before the application responds. That’s caused by the dispatcher reloading stuff. For development it’s a price worth paying, but in production it would be unacceptable. Because of this, this feature is disabled for production deployment (see Chapter 16, <a href="../Text/f_0091.html#chp.deployment">​<em>Task K: Deployment and Production</em>​</a>).</p>
    </div>
  </div>

  <h4 id="heading_id_5">Adding the Time</h4>

  <p id="N10B45">Our original problem was to display the time to users of our application. We now know how to make our application display dynamic data. The second issue we have to address is working out where to get the time from.</p>

  <p id="N10B48">We’ve shown that the approach of embedding a call to Ruby’s <code class="cf methodname">Time.now</code> method in our <code class="cf filename">hello.html.erb</code> template works. Each time we access this page, the user will see the current time substituted into the body of the response. And for our trivial application, that might be good enough. In general, though, we probably want to do something slightly different. We’ll move the determination of the time to be displayed into the controller and leave the view with the simple job of displaying it. We’ll change our action method in the controller to set the time value into an instance variable called <code class="cf variable">@time</code>:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/work/demo3/app/controllers/say_controller.rb">rails31/work/demo3/app/controllers/say_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> SayController &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> hello</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1">@time = Time.now</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> goodbye</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N10B85">In the <code class="cf fileextension">html.erb</code> template, we’ll use this instance variable to substitute the time into the output:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/work/demo3/app/views/say/hello.html.erb">rails31/work/demo3/app/views/say/hello.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h1&gt;</strong>Hello from Rails!<strong class="prompt">&lt;/h1&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;p&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1">It is now &lt;%= @time %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/p&gt;</strong></code></td>
    </tr>
  </table>

  <p id="N10BA6">When we refresh our browser window, we will again see the current time, showing that the communication between the controller and the view was successful.</p>

  <p id="N10BA9">Why did we go to the extra trouble of setting the time to be displayed in the controller and then using it in the view? Good question. In this application, it doesn’t make much difference, but by putting the logic in the controller instead, we buy ourselves some benefits. For example, we may want to extend our application in the future to support users in many countries. In that case, we’d want to localize the display of the time, choosing a time appropriate to their time zone. That would be a fair amount of application-level code, and it would probably not be appropriate to embed it at the view level. By setting the time to display in the controller, we make our application more flexible&mdash;we can change the time zone in the controller without having to update any view that uses that time object. The time is <span class="emph">data</span>, and it should be supplied to the view by the controller. We’ll see a lot more of this when we introduce models into the equation.</p>

  <h4 id="heading_id_6">The Story So Far</h4>

  <p id="N10BBE">Let’s briefly review how our current application works:</p>

  <ol>
    <li>
      <p id="N10BC4">The user navigates to our application. In our case, we do that using a local URL such as <a href="http://localhost:3000/say/hello">http://localhost:3000/say/hello</a>.</p>
    </li>

    <li>
      <p id="N10BE1">Rails then matches the route pattern, which it previously split into two parts and analyzed.</p>

      <p id="N10BE4">The <code class="cf ic">say</code> part is taken to be the name of a controller, so Rails creates a new instance of the Ruby class <code class="cf class">SayController</code> (which it finds in <code class="cf filename">app/controllers/</code> <code class="cf filename">say_controller.rb</code>).</p>
    </li>

    <li>
      <p id="N10BF3">The next part of the pattern, <code class="cf ic">hello</code>, identifies an action. Rails invokes a method of that name in the controller. This action method creates a new <code class="cf class">Time</code> object holding the current time and tucks it away in the <code class="cf variable">@time</code> instance variable.</p>
    </li>

    <li>
      <p id="N10C06">Rails looks for a template to display the result. It searches the directory <code class="cf dir">app/views</code> for a subdirectory with the same name as the controller (<code class="cf dir">say</code>) and in that subdirectory for a file named after the action (<code class="cf filename">hello.html.erb</code>).</p>
    </li>

    <li>
      <p id="N10C13">Rails processes this file through the ERB templating system, executing any embedded Ruby and substituting in values set up by the controller.</p>
    </li>

    <li>
      <p id="N10C20">The result is returned to the browser, and Rails finishes processing this request.</p>
    </li>
  </ol>

  <p id="N10C23">This isn’t the whole story&mdash;Rails gives you lots of opportunities to override this basic workflow (and we’ll be taking advantage of them shortly). As it stands, our story illustrates convention over configuration, one of the fundamental parts of the philosophy of Rails. By providing convenient defaults and by applying certain conventions on how a URL is constructed or in what file a controller definition is placed and what class name and method names are used, Rails applications are typically written using little or no external configuration&mdash;things just knit themselves together in a natural way.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
