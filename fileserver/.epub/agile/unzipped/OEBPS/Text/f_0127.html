<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">23.3 Managing Tables</h2>

  <p id="N1E2C3">So far we’ve been using migrations to manipulate the columns in existing tables. Now let’s look at creating and dropping tables:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> CreateOrderHistories &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :order_histories <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.integer :order_id, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.text :notes</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.timestamps</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E30C"><code class="cf methodname">create_table</code> takes the name of a table (remember, table names are plural) and a block. (It also takes some optional parameters that we’ll look at in a minute.) The block is passed a table definition object, which we use to define the columns in the table.</p>

  <p id="N1E31C">Generally the call to <code class="cf methodname">drop_table</code> is not needed, as <code class="cf methodname">add_table</code> is reversible. <code class="cf methodname">drop_table</code> accepts a single parameter, which is the name of the table to drop.</p>

  <p id="N1E328">The calls to the various table definition methods should look familiar&mdash;they’re similar to the <code class="cf ic">add_column</code> method we used previously except these methods don’t take the name of the table as the first parameter, and the name of the method itself is the data type desired. This reduces repetition.</p>

  <p id="N1E32E">Note that we don’t define the <code class="cf sqlcolumn">id</code> column for our new table. Unless we say otherwise, Rails migrations automatically add a primary key called <code class="cf sqlcolumn">id</code> to all tables they create. For a deeper discussion of this, see <a href="#sec.pk">​<em>Primary Keys</em>​</a>.</p>

  <p id="N1E33A">The <code class="cf ic">timestamps</code> method creates both the <code class="cf ic">created_at</code> and <code class="cf ic">updated_at</code> columns, with the correct <code class="cf ic">timestamp</code> data type. Although there is no requirement to add these columns to any particular table, this is yet another example of Rails making it easy for a common convention to be implemented easily and consistently.</p>

  <h3 id="heading_id_3">Options for Creating Tables</h3>

  <p id="N1E34D">You can pass a hash of options as a second parameter to <code class="cf ic">create_table</code>.</p>

  <p id="N1E353">If you specify <code class="cf ic">force: true</code>, the migration will drop an existing table of the same name before creating the new one. This is a useful option if you want to create a migration that forces a database into a known state, but there’s clearly a potential for data loss.</p>

  <p id="N1E359">The <code class="cf ic">temporary: true</code> option creates a temporary table&mdash;one that goes away when the application disconnects from the database. This is clearly pointless in the context of a migration, but as we will see later, it does have its uses elsewhere.</p>

  <p id="N1E35F">The <code class="cf ic">options: "xxxx"</code> parameter lets you specify options to your underlying database. These are added to the end of the <code class="cf ic">CREATE TABLE</code> statement, right after the closing parenthesis. Although this is rarely necessary with SQLite 3, it may at times be useful with other database servers. For example, some versions of MySQL allow you to specify the initial value of the autoincrementing <code class="cf sqlcolumn">id</code> column. We can pass this in through a migration as follows:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :tickets, options: <em class="string">"auto_increment = 10000"</em> <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.text :description</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.timestamps</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E386">Behind the scenes, migrations will generate the following DDL from this table description when configured for MySQL:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">CREATE</strong> <strong class="prompt">TABLE</strong> <em class="string">"tickets"</em> (</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">"id"</em> <strong class="prompt">int</strong>(11) <strong class="prompt">default</strong> null <strong class="prompt">auto_increment</strong> <strong class="prompt">primary</strong> <strong class="prompt">key</strong>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">"description"</em> <strong class="prompt">text</strong>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">"created_at"</em> <strong class="prompt">datetime</strong>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">"updated_at"</em> <strong class="prompt">datetime</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">) <strong class="prompt">auto_increment</strong> = 10000;</code></td>
    </tr>
  </table>

  <p id="N1E3D1">Be careful when using the <code class="cf ic">:options</code> parameter with MySQL. The Rails MySQL database adapter sets a default option of <code class="cf ic">ENGINE=InnoDB</code>. This overrides any local defaults you may have and forces migrations to use the InnoDB storage engine for new tables. However, if you override <code class="cf ic">:options</code>, you’ll lose this setting; new tables will be created using whatever database engine is configured as the default for your site. You may want to add an explicit <code class="cf ic">ENGINE=InnoDB</code> to the options string to force the standard behavior in this case. You probably want to keep using InnoDB if you’re using MySQL, because this engine gives you transaction support. You might need transaction support in your application, and you’ll definitely need it in your tests if you’re using the default of transactional test fixtures.</p>

  <h3 id="heading_id_4">Renaming Tables</h3>

  <p id="N1E3F2">If refactoring leads us to rename variables and columns, then it’s probably not a surprise that we sometimes find ourselves renaming tables, too. Migrations support the <code class="cf methodname">rename_table</code> method:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> RenameOrderHistories &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">rename_table :order_histories, :order_notes</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E42D">Note how the <code class="cf ic">down</code> method undoes the change by renaming the table back.</p>

  <h4 id="heading_id_5">Problems with rename_table</h4>

  <p id="N1E437">There’s a subtle problem when we rename tables in migrations.</p>

  <p id="N1E43A">For example, let’s assume that in migration 4 we create the <code class="cf sqltable">order_histories</code> table and populate it with some data:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> up</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :order_histories <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.integer :order_id, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.text :notes</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.timestamps</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find :first</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">OrderHistory.create(order_id: order, notes: <em class="string">"test"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E474">Later, in migration 7, we rename the table <code class="cf sqltable">order_histories</code> to <code class="cf sqltable">order_notes</code>. At this point we’ll also have renamed the model <code class="cf class">OrderHistory</code> to <code class="cf class">OrderNote</code>.</p>

  <p id="N1E483">Now we decide to drop our development database and reapply all migrations. When we do so, the migrations throw an exception in migration 4: our application no longer contains a class called <code class="cf class">OrderHistory</code>, so the migration fails.</p>

  <p id="N1E489">One solution, proposed by Tim Lucas, is to create local, dummy versions of the model classes needed by a migration within the migration itself. For example, the following version of the fourth migration will work even if the application no longer has an <code class="cf class">OrderHistory</code> class:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> CreateOrderHistories &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Order &lt; ActiveRecord::Base; <strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> OrderHistory &lt; ActiveRecord::Base; <strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :order_histories <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.integer :order_id, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.text :notes</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.timestamps</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find :first</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">OrderHistory.create(order: order_id, notes: <em class="string">"test"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E4E4">This works as long as our model classes do not contain any additional functionality that would have been used in the migration&mdash;all we’re creating here is a bare-bones version.</p>

  <h3 id="heading_id_6">Defining Indices</h3>

  <p id="N1E4EB">Migrations can (and probably should) define indices for tables. For example, we might notice that once your application has a large number of orders in the database, searching based on the customer’s name takes longer than we’d like. It’s time to add an index using the appropriately named <code class="cf methodname">add_index</code> method:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> AddCustomerNameIndexToOrders &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_index :orders, :name</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E531">If we give <code class="cf ic">add_index</code> the optional parameter <code class="cf ic">unique: true</code>, a unique index will be created, forcing values in the indexed column to be unique.</p>

  <p id="N1E53A">By default the index will be given the name <span class="emph">index_table_on_column</span>. We can override this using the <code class="cf ic">name: "somename"</code> option. If we use the <code class="cf ic">:name</code> option when adding an index, we’ll also need to specify it when removing the index.</p>

  <p id="N1E546">We can create a <span class="emph">composite index</span>&mdash;an index on multiple columns&mdash;by passing an array of column names to <code class="cf ic">add_index</code>. In this case, only the first column name will be used when naming the index.</p>

  <p id="N1E54F">Indices are removed using the <code class="cf methodname">remove_index</code> method.</p>

  <h3 id="sec.pk">Primary Keys</h3>

  <p id="N1E55A">Rails assumes every table has a numeric primary key (normally called <code class="cf sqlcolumn">id</code>) and ensures the value of this column is unique for each new row added to a table.</p>

  <p id="N1E56B">We’ll rephrase that.</p>

  <p id="N1E56E">Rails really doesn’t work too well unless each table has a numeric primary key. It is less fussy about the name of the column. So, for your average Rails application, our strong advice is to go with the flow and let Rails have its <code class="cf sqlcolumn">id</code> column.</p>

  <p id="p.mig.primary.key">If you decide to be adventurous, you can start by using a different name for the primary key column (but keeping it as an incrementing integer). Do this by specifying a <code class="cf ic">:primary_key</code> option on the <code class="cf ic">create_table</code> call:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :tickets, primary_key: :number <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.text :description</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.timestamps</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E599">This adds the <code class="cf sqlcolumn">number</code> column to the table and sets it up as the primary key:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">$ <strong class="prompt">sqlite3 db/development.sqlite3 ".schema tickets"</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">CREATE TABLE tickets ("number" INTEGER PRIMARY KEY AUTOINCREMENT</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">NOT NULL, "description" text DEFAULT NULL, "created_at" datetime</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">DEFAULT NULL, "updated_at" datetime DEFAULT NULL);</code></td>
    </tr>
  </table>

  <p id="N1E5B7">The next step in the adventure might be to create a primary key that isn’t an integer. Here’s a clue that the Rails developers don’t think this is a good idea: migrations don’t let you do this (at least not directly).</p>

  <h4 id="heading_id_7">Tables with No Primary Key</h4>

  <p id="N1E5BE">Sometimes we may need to define a table that has no primary key. The most common case in Rails is for <span class="emph">join tables</span>&mdash;tables with just two columns where each column is a foreign key to another table. To create a join table using migrations, we have to tell Rails not to automatically add an <code class="cf sqlcolumn">id</code> column:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">create_table :authors_books, id: false <strong class="prompt">do</strong> |t|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.integer :author_id, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">t.integer :book_id, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E5E5">In this case, you might want to investigate creating one or more indices on this table to speed navigation between books and authors.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
