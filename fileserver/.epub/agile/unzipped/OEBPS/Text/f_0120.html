<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.etags">22.1 Playing Nice with Client Caches</h2>

  <p id="N1D590">Clients (generally, but not always, browsers) often have caches too. Intermediaries between your server and the client may also provide caching services. Your web server has a cache. You can help optimize these caches (and therefore reduce load on your server) by providing HTTP headers. Doing so is entirely optional and won’t always result in a bandwidth reduction, but on the other hand, sometimes the savings can be quite significant.</p>

  <h3 id="heading_id_2">Expiration Headers</h3>

  <p id="N1D5A3">The most efficient request is the request that is never made. Many pages (particularly images, scripts, and stylesheets) change very rarely yet may be referenced fairly frequently. One way to ensure that re-retrievals are optimized out before they get to your server is to provide an <code class="cf ic">Expires</code> header.</p>

  <p id="N1D5A9">Although an <code class="cf ic">Expires</code> header may provide a number of different options, the most common usage is to indicate how long the given response is to be considered “good for,” suggesting that the client need not re-request this data in the interim. Calling the <code class="cf methodname">expires_in</code> method in your controller achieves this result:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expires_in 10.minutes, public: true</code></td>
    </tr>
  </table>

  <p id="N1D5C2">A server should not provide a date more than one year in the future on <code class="cf ic">Expires</code> headers.</p>

  <p id="N1D5C8">An alternate use for the <code class="cf ic">Expires</code> header is to indicate that the response is not to be cached at all. This can be accomplished with the <code class="cf methodname">expires_now</code> method, which understandably takes no parameters.</p>

  <p id="N1D5D1">Let’s take a look at that header in the context of the Depot application. Your storefront is going to be visited by bazillions of visitors. You want that to happen. And you want their experience to be a good one.</p>

  <p id="N1D5D4">In order to produce that page, the controller needs to communicate to the models, which need to communicate to the database. Then the results need to be processed by the view, and this will result in a response going across the wire and back across the Internet. And that’s just the start of the fun, as the browser will immediately come back and ask for more. Stylesheet. JavaScript. Images.</p>

  <p id="N1D5D7">And frankly, none of that is likely to change that frequently in production. Add to that that there typically are a lot more users browsing than buying. If a browser gets a catalog listing that is seven minutes old, it is just fine. Caching the store front but not the checkout will reduce your server load significantly.</p>

  <p id="N1D5DA">And there really is no reason to get greedy. Setting the expiration to be ten minutes may be plenty. Sure, it is likely to change a lot less frequently than that, but if your server can’t process one request every ten minutes, either you have a poorly designed application or a rather slow server.</p>

  <p id="N1D5DD">Best of all, when run in production mode, Rails handles this automatically for all the assets in your application. That includes stylesheets, JavaScripts, and images. The way it does this is clever and worth understanding. To see it in action, restart your server in production mode:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">rails server -e production</code></td>
    </tr>
  </table>

  <p id="N1D5EB">Now bring up the Depot storefront. It doesn’t look any different, does it? Now view source. Look for the references to the assets: the <code class="cf ic">link</code> tag, the <code class="cf ic">script</code> tag, and the <code class="cf ic">img</code> tags. Each starts with <code class="cf ic">/assets/</code> and ends with the extension you would expect, but in between is a long string of hexadecimal characters.</p>

  <p id="N1D5FA">Rails has computed a hash of the response and included that hash in the name. At the same time, it has provided an expires header that says that this resource will not change for a full year. And the reason why Rails can guarantee that is that if you so much as change a single bit in that object, that will change the hash, and as far as the client is concerned that will be an entirely different resource.</p>

  <p id="N1D5FD">What does this mean to the end user? Well, a first-time user who comes to the storefront will end up downloading all of the scripts and stylesheets that they will need, as Rails will bundle each of these up into a single file. A few minutes later when this user proceeds to the checkout page, if the file hasn’t changed, then the hash won’t have either. The browser will match up the names, obtain the resource from its own local cache, and not request it again from the server.</p>

  <p id="N1D600">Clever, eh?</p>

  <p id="N1D603">You can find additional information on more expiration options in the HTTP specification.<a href="../Text/f_0123.html#FOOTNOTE-52" id="FNPTR-52">[52]</a></p>

  <p id="N1D617">Be aware that if you are using page-level caching, requests that are cached at the server won’t get to your application, so this mechanism needs to also be implemented at the server level to be effective. Here’s an example for the Apache web server:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;LocationMatch</strong> "^/assets/.*$"<strong class="prompt">&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Header unset Last-Modified</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Header unset ETag</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">FileETag None</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ExpiresActive On</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ExpiresDefault "access plus 1 year"</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/LocationMatch&gt;</strong></code></td>
    </tr>
  </table>

  <h3 id="heading_id_3">LastModified and ETag Support</h3>

  <p id="N1D640">The next best thing to eliminating requests entirely is to respond immediately with an HTTP <code class="cf ic">304 Not Modified</code> response. This will instruct user agents and intermediaries to use the version of this page that they already have in their cache. At a minimum, such responses will save on bandwidth. Often this will enable you to eliminate the server load associated with producing a more complete response.</p>

  <p id="N1D64C">If you are already doing page-level caching with Apache, the web server will generally take care of this for you, based on the timestamp associated with the on-disk cache.</p>

  <p id="N1D64F">For all other requests, Rails will produce the necessary HTTP headers for you, if you call one of the <code class="cf methodname">stale?</code> or <code class="cf methodname">fresh_when</code> methods.</p>

  <p id="N1D664">Both methods accept both a <code class="cf ic">:last_modified</code> timestamp (in UTC) and an <code class="cf ic">:etag</code>. The latter is either an object on which the response depends or an array of such objects. Such objects need to respond to either <code class="cf methodname">cache_key</code> or <code class="cf methodname">to_param</code>. Active Record takes care of this for you.</p>

  <p id="N1D673">To demonstrate how this can be used in the context of Depot, let’s introduce a single method to the <code class="cf class">Product</code> model, which finds the product that was most recently updated:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_u/app/models/product.rb">rails31/depot_u/app/models/product.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> self.latest</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Product.order(<em class="string">'updated_at desc'</em>).limit(1).first</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1D691">First we’ll show the <code class="cf methodname">stale?</code> method, which is typically used in <code class="cf ic">if</code> statements when custom rendering is involved:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> index</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">latest = Product.latest</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> stale?(etag: latest, last_modified: latest.updated_at.utc)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1D6C1"><code class="cf methodname">fresh_when</code> is often more convenient when you are making use of default rendering because it will produce a <code class="cf ic">304 Not Modified</code> response for you:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_u/app/models/product.rb">rails31/depot_u/app/models/product.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> self.latest</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Product.order(<em class="string">'updated_at desc'</em>).limit(1).first</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1D6E1">We’ve talked about how easy this is to implement. Now let’s talk about downsides that you need to be aware of.</p>

  <p id="N1D6E4">In the case of your Depot store front, ETags aren’t going to help much. You likely won’t face the problem of the same person getting the same page over and over again. That’s easy, and a response of <code class="cf ic">304 Not Modified</code> solves it handily. No, what you are likely to see is lots of different people visiting the site, each of whom hasn’t seen it recently and wants to get the latest.</p>

  <p id="N1D6EA">Expiring <span class="emph">without</span> specifying the <code class="cf ic">public</code> attribute isn’t any better at solving this problem. This is still a private negotiation between your server and each and every client. Setting the <code class="cf ic">public</code> attribute to <code class="cf ic">true</code> changes everything. It makes the page eligible for caching by your web server and even potentially by other intermediaries on the web.</p>

  <p id="N1D6F9">But for this to work properly, the content must truly be public. It can’t be different for different users. In order to use this with the current storefront, you’ll need to make a few changes. You can’t have administrative links that only are added if the user is logged on. Nor can you make use of a <code class="cf methodname">hidden_div_if</code> helper. You’ll need to have a separate page for administrators, and a separate page for a visible cart. You still can use Ajax techniques to update the page; you only need to avoid server-side <code class="cf ic">if</code> statements in your views.</p>

  <p id="N1D702">There is one other matter to be aware of; in this case it’s both a plus and a minus. If your HTML is cached so that new requests for this page from the client never make it to the Rails application, then the client won’t be aware of changes in the hash part of the assets’ name, so they won’t fetch updates to images, JavaScripts, and stylesheets until the HTML page expires.</p>

  <p id="N1D705">All in all, HTML caching is well worth the effort. In a situation where this is not for you, Rails does have more to offer. However, it is generally worthwhile to try to make HTTP caching work for you before you explore Rails’ caching options.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
