<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
</head>

<body>
  <h2 id="heading_id_2">3.1 Models, Views, and Controllers</h2>

  <p id="N10E2B">Back in 1979, Trygve Reenskaug came up with a new architecture for developing interactive applications. In his design, applications were broken into three types of components: models, views, and controllers.</p>

  <p id="N10E33">The <span class="firstuseinline">model</span> is responsible for maintaining the state of the application. Sometimes this state is transient, lasting for just a couple of interactions with the user. Sometimes the state is permanent and will be stored outside the application, often in a database.</p>

  <p id="N10E39">A model is more than just data; it enforces all the business rules that apply to that data. For example, if a discount shouldn’t be applied to orders of less than $20, the model will enforce the constraint. This makes sense; by putting the implementation of these business rules in the model, we make sure that nothing else in the application can make our data invalid. The model acts as both a gatekeeper and a data store.</p>

  <p id="N10E42">The <span class="firstuseinline">view</span> is responsible for generating a user interface, normally based on data in the model. For example, an online store will have a list of products to be displayed on a catalog screen. This list will be accessible via the model, but it will be a view that accesses the list from the model and formats it for the end user. Although the view may present the user with various ways of inputting data, the view itself never handles incoming data. The view’s work is done once the data is displayed. There may well be many views that access the same model data, often for different purposes. In the online store, there’ll be a view that displays product information on a catalog page and another set of views used by administrators to add and edit products.</p>

  <p id="N10E4E"><span class="firstuseinline">Controllers</span> orchestrate the application. Controllers receive events from the outside world (normally user input), interact with the model, and display an appropriate view to the user.</p>

  <p id="N10E59">This triumvirate&mdash;the model, view, and controller&mdash;together form an architecture known as MVC. To learn how the three concepts fit together, see Figure 4, <a href="#fig.mvc">​<em>The Model-View-Controller architecture</em>​</a>.</p>

  <table class="figure" id="fig.mvc">
    <tr>
      <td><img alt="images/basic_mvc.png" src="../Images/basic_mvc.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 4. The Model-View-Controller architecture</b>
      </td>
    </tr>
  </table>

  <p id="N10E68">The MVC architecture was originally intended for conventional GUI applications, where developers found the separation of concerns led to far less coupling, which in turn made the code easier to write and maintain. Each concept or action was expressed in just one well-known place. Using MVC was like constructing a skyscraper with the girders already in place&mdash;it was a lot easier to hang the rest of the pieces with a structure already there. During the development of our application, we will be making heavy use of Rails’ ability to generate <span class="emph">scaffolding</span> for our application.</p>

  <p id="N10E73">Ruby on Rails is an MVC framework, too. Rails enforces a structure for your application&mdash;you develop models, views, and controllers as separate chunks of functionality, and it knits them all together as your program executes. One of the joys of Rails is that this knitting process is based on the use of intelligent defaults so that you typically don’t need to write any external configuration metadata to make it all work. This is an example of the Rails philosophy of favoring convention over configuration.</p>

  <p id="N10E7D">In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request itself should be parsed. Ultimately, this phase identifies a particular method (called an <span class="firstuseinline">action</span> in Rails parlance) somewhere in the controller code. The action might look at data in the request, it might interact with the model, and it might cause other actions to be invoked. Eventually the action prepares information for the view, which renders something to the user.</p>

  <p id="N10E8A">Rails handles an incoming request as shown in Figure 5, <a href="#fig.rails.mvc">​<em>Rails and MVC</em>​</a>. In this example, the application has previously displayed a product catalog page, and the user has just clicked the <code class="cf keystroke">Add to Cart</code> button next to one of the products. This button posts to <a href="http://localhost:3000/line_items?product_id=2">http://localhost:3000/line_items?product_id=2</a>, where <code class="cf ic">line_items</code> is a resource in our application and 2 is our internal id for the selected product.</p>

  <table class="figure" id="fig.rails.mvc">
    <tr>
      <td><img alt="images/rails_mvc.png" src="../Images/rails_mvc.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 5. Rails and MVC</b>
      </td>
    </tr>
  </table>

  <p id="N10EA9">The routing component receives the incoming request and immediately picks it apart. The request contains a path (<code class="cf ic">/line_items?product_id=2</code>) and a method (this button does a POST operation; other common methods are GET, PUT, and DELETE). In this simple case, Rails takes the first part of the path, <code class="cf ic">line_items</code>, as the name of the controller and the <code class="cf ic">product_id</code> as the id of a product. By convention, POST methods are associated with <code class="cf methodname">create</code> actions. As a result of all this analysis, the router knows it has to invoke the <code class="cf methodname">create</code> method in the controller class <code class="cf class">LineItemsController</code> (we’ll talk about naming conventions <a href="../Text/f_0101.html#sec.naming">​here​</a>).</p>

  <p id="N10EC7">The <code class="cf methodname">create</code> method handles user requests. In this case, it finds the current user’s shopping cart (which is an object managed by the model). It also asks the model to find the information for product 2. It then tells the shopping cart to add that product to itself. (See how the model is being used to keep track of all the business data? The controller tells it <span class="emph">what</span> to do, and the model knows <span class="emph">how</span> to do it.)</p>

  <p id="N10ED3">Now that the cart includes the new product, we can show it to the user. The controller invokes the view code, but before it does, it arranges things so that the view has access to the cart object from the model. In Rails, this invocation is often implicit; again, conventions help link a particular view with a given action.</p>

  <p id="N10ED6">That’s all there is to an MVC web application. By following a set of conventions and partitioning your functionality appropriately, you’ll discover that your code becomes easier to work with and your application becomes easier to extend and maintain. Seems like a good trade.</p>

  <p id="N10EE0">If MVC is simply a question of partitioning your code a particular way, you might be wondering why you need a framework such as Ruby on Rails. The answer is straightforward: Rails handles all of the low-level housekeeping for you&mdash;all those messy details that take so long to handle by yourself&mdash;and lets you concentrate on your application’s core functionality. Let’s see how.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
