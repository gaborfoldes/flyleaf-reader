<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.naming">18.2 Naming Conventions</h2>

  <p id="N18EC1">Newcomers to Rails are sometimes puzzled by the way it automatically handles the naming of things. They’re surprised that they call a model class <code class="cf class">Person</code> and Rails somehow knows to go looking for a database table called <code class="cf sqltable">people</code>. In this section, you’ll learn how this implicit naming works.</p>

  <p id="N18ED5">The rules here are the default conventions used by Rails. You can override all of these conventions using configuration options.</p>

  <h3 id="heading_id_2">Mixed Case, Underscores, and Plurals</h3>

  <p id="N18EDC">We often name variables and classes using short phrases. In Ruby, the convention is to have variable names where the letters are all lowercase and words are separated by underscores. Classes and modules are named differently: there are no underscores, and each word in the phrase (including the first) is capitalized. (We’ll call this <span class="emph">mixed case</span>, for fairly obvious reasons.) These conventions lead to variable names such as <code class="cf ic">order_status</code> and class names such as <code class="cf class">LineItem</code>.</p>

  <p id="N18EF4">Rails takes this convention and extends it in two ways. First, it assumes that database table names, such as variable names, have lowercase letters and underscores between the words. Rails also assumes that table names are always plural. This leads to table names such as <code class="cf sqltable">orders</code> and <code class="cf sqltable">third_parties</code>.</p>

  <p id="N18F08">On another axis, Rails assumes that files are named in lowercase with underscores.</p>

  <p id="N18F0B">Rails uses this knowledge of naming conventions to convert names automatically. For example, your application might contain a model class that handles line items. You’d define the class using the Ruby naming convention, calling it <code class="cf class">LineItem</code>. From this name, Rails would automatically deduce the following:</p>

  <ul>
    <li>
      <p id="N18F1A">That the corresponding database table will be called <code class="cf sqltable">line_items</code>. That’s the class name, converted to lowercase, with underscores between the words and pluralized.</p>
    </li>

    <li>
      <p id="N18F21">Rails would also know to look for the class definition in a file called <code class="cf filename">line_item.rb</code> (in the <code class="cf dir">app/models</code> directory).</p>
    </li>
  </ul>

  <p id="N18F2A">Rails controllers have additional naming conventions. If our application has a store controller, then the following happens:</p>

  <ul>
    <li>
      <p id="N18F36">Rails assumes the class is called <code class="cf class">StoreController</code> and that it’s in a file named <code class="cf filename">store_controller.rb</code> in the <code class="cf dir">app/controllers</code> directory.</p>
    </li>

    <li>
      <p id="N18F43">It also assumes there’s a helper module named <code class="cf class">StoreHelper</code> in the file <code class="cf filename">store_helper.rb</code> located in the <code class="cf dir">app/helpers</code> directory.</p>
    </li>

    <li>
      <p id="N18F50">It will look for view templates for this controller in the <code class="cf dir">app/views/store</code> directory.</p>
    </li>

    <li>
      <p id="N18F57">It will by default take the output of these views and wrap them in the layout template contained in the file <code class="cf filename">store.html.erb</code> or <code class="cf filename">store.xml.erb</code> in the directory <code class="cf dir">app/views/layouts</code>.</p>
    </li>
  </ul>

  <table class="figure" id="fig.naming">
    <tr>
      <td><img alt="images/naming.png" src="../Images/naming.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 45. How naming conventions work across a Rails application</b>
      </td>
    </tr>
  </table>

  <p id="N18F7B">All these conventions are shown in Figure 45, <a href="#fig.naming">​<em>How naming conventions work across a Rails application</em>​</a>.</p>

  <p id="N18F81">There’s one extra twist. In normal Ruby code you have to use the <code class="cf ic">require</code> keyword to include Ruby source files before you reference the classes and modules in those files. Because Rails knows the relationship between filenames and class names, <code class="cf ic">require</code> is normally not necessary in a Rails application. Instead, the first time you reference a class or module that isn’t known, Rails uses the naming conventions to convert the class name to a filename and tries to load that file behind the scenes. The net effect is that you can typically reference (say) the name of a model class, and that model will be automatically loaded into your application.</p>

  <h3 id="sec.group.controllers">Grouping Controllers into Modules</h3>

  <p id="N18F9F">So far, all our controllers have lived in the <code class="cf dir">app/controllers</code> directory. It is sometimes convenient to add more structure to this arrangement. For example, our store might end up with a number of controllers performing related but disjoint administration functions. Rather than pollute the top-level namespace, we might choose to group them into a single <code class="cf ic">admin</code> namespace.</p>

  <p id="N18FB3">Rails does this using a simple naming convention. If an incoming request has a controller named (say) <code class="cf ic">admin/book</code>, Rails will look for the controller called <code class="cf filename">book_controller</code> in the directory <code class="cf dir">app/controllers/admin</code>. That is, the final part of the controller name will always resolve to a file called <span class="emph">name</span> <code class="cf ic">_controller.rb</code>, and any leading path information will be used to navigate through subdirectories, starting in the <code class="cf dir">app/controllers</code> directory.</p>

  <p id="N18FC7">Imagine that our program has two such groups of controllers (say, <code class="cf ic">admin/</code> <span class="emph">xxx</span> and <code class="cf ic">content/</code> <span class="emph">xxx</span>) and that both groups define a book controller. There’d be a file called <code class="cf filename">book_controller.rb</code> in both the <code class="cf dir">admin</code> and <code class="cf dir">content</code> subdirectories of <code class="cf dir">app/controllers</code>. Both of these controller files would define a class named <code class="cf class">BookController</code>. If Rails took no further steps, these two classes would clash.</p>

  <p id="N18FE3">To deal with this, Rails assumes that controllers in subdirectories of the directory <code class="cf dir">app/controllers</code> are in Ruby modules named after the subdirectory. Thus, the book controller in the <code class="cf dir">admin</code> subdirectory would be declared like this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Admin::BookController &lt; ActionController::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19002">The book controller in the <code class="cf dir">content</code> subdirectory would be in the <code class="cf class">Content</code> module:</p>

  <div class="xxxsays">
    <div class="heading">
      <div class="persons-picture"><img alt="David says:" src="../Images/David.png" /></div>

      <div class="label">
        David says:
      </div>

      <div class="title">
        Why Plurals for Tables?
      </div>
    </div>

    <div class="body">
      <p id="N1900F">Because it sounds good in conversation. Really. “Select a Product from products.” And “Order has_many :line_items.”</p>

      <p id="N1901D">The intent is to bridge programming and conversation by creating a domain language that can be shared by both. Having such a language means cutting down on the mental translation that otherwise confuses the discussion of a <span class="emph">product description</span> with the client when it’s really implemented as <span class="emph">merchandise body</span>. These communications gaps are bound to lead to errors.</p>

      <p id="N19026">Rails sweetens the deal by giving you most of the configuration for free if you follow the standard conventions. Developers are thus rewarded for doing the right thing, so it’s less about giving up “your ways” and more about getting productivity for free.</p>
    </div>
  </div>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Content::BookController &lt; ActionController::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1903F">The two controllers are therefore kept separate inside your application.</p>

  <p id="N19042">The templates for these controllers appear in subdirectories of <code class="cf dir">app/views</code>. Thus, the view template corresponding to this request:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">http://my.app/admin/book/edit/1234</code></td>
    </tr>
  </table>

  <p id="N19052">will be in this file:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">app/views/admin/book/edit.html.erb</code></td>
    </tr>
  </table>

  <p id="N1905F">You’ll be pleased to know that the controller generator understands the concept of controllers in modules and lets you create them with commands such as this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">myapp&gt; <strong class="prompt">rails generate controller Admin::Book action1 action2 ...</strong></code></td>
    </tr>
  </table>

  <h3 id="heading_id_3">What We Just Did</h3>

  <p id="N19074">Everything in Rails has a place, and we systematically explored each of those nooks and crannies. In each place, files and the data contained in them follow naming conventions, and we covered that too. Along the way, we filled in a few missing pieces:</p>

  <ul>
    <li>
      <p id="N1907A">We generated both API and user guide documentation for Rails itself.</p>
    </li>

    <li>
      <p id="N1907E">We added a Rake task to print the migrated versions.</p>
    </li>

    <li>
      <p id="N19082">We showed how to separately configure each of the Rails execution environments.</p>
    </li>
  </ul>

  <p id="N19085">Next up is the major subsystems of Rails, starting with the largest, Active Record.</p>

  <div class="footnotes">
    <h4 id="heading_id_4">Footnotes</h4>

    <table cellspacing="3">
      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0100.html#FNPTR-36" id="FOOTNOTE-36">[36]</a></td>

        <td>
          <p id="N18A2B"><a href="http://guides.rubyonrails.org/rails_on_rack.html">http://guides.rubyonrails.org/rails_on_rack.html</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0100.html#FNPTR-37" id="FOOTNOTE-37">[37]</a></td>

        <td>
          <p id="N18A42"><a href="https://github.com/carlhuda/bundler">https://github.com/carlhuda/bundler</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0100.html#FNPTR-38" id="FOOTNOTE-38">[38]</a></td>

        <td>
          <p id="N18B42">...which we did in the Pragmatic Programmer store.</p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0100.html#FNPTR-39" id="FOOTNOTE-39">[39]</a></td>

        <td>
          <p id="N18D39"><a href="http://wiki.rubyonrails.org/rails/pages/AvailableGenerators">http://wiki.rubyonrails.org/rails/pages/AvailableGenerators</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0100.html#FNPTR-40" id="FOOTNOTE-40">[40]</a></td>

        <td>
          <p id="N18EB8"><a href="http://guides.rubyonrails.org/configuring.html">http://guides.rubyonrails.org/configuring.html</a></p>
        </td>
      </tr>
    </table>
  </div>

  <div class="copyright">
    Copyright © 2011, The Pragmatic Bookshelf.
  </div><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
