<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">3.2 Rails Model Support</h2>

  <p id="N10EE7">In general, we’ll want our web applications to keep their information in a relational database. Order-entry systems will store orders, line items, and customer details in database tables. Even applications that normally use unstructured text, such as weblogs and news sites, often use databases as their back-end data store.</p>

  <p id="N10EF2">Although it might not be immediately apparent from the SQL<a href="../Text/f_0029.html#FOOTNOTE-15" id="FNPTR-15">[15]</a> you use to access them, relational databases are actually designed around mathematical set theory. Although this is good from a conceptual point of view, it makes it difficult to combine relational databases with object-oriented (OO) programming languages. Objects are all about data and operations, and databases are all about sets of values. Operations that are easy to express in relational terms are sometimes difficult to code in an OO system. The reverse is also true.</p>

  <p id="N10EFD">Over time, folks have worked out ways of reconciling the relational and OO views of their corporate data. Let’s look at the way that Rails chooses to map relational data onto objects.</p>

  <h3 id="heading_id_3">Object-Relational Mapping</h3>

  <p id="N10F04">ORM libraries map database tables to classes. If a database has a table called <code class="cf sqltable">orders</code>, our program will have a class named <code class="cf class">Order</code>. Rows in this table correspond to objects of the class&mdash;a particular order is represented as an object of class <code class="cf class">Order</code>. Within that object, attributes are used to get and set the individual columns. Our <code class="cf class">Order</code> object has methods to get and set the amount, the sales tax, and so on.</p>

  <p id="N10F23">In addition, the Rails classes that wrap our database tables provide a set of class-level methods that perform table-level operations. For example, we might need to find the order with a particular id. This is implemented as a class method that returns the corresponding <code class="cf class">Order</code> object. In Ruby code, this might look like this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(1)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts <em class="string">"Customer</em> #{order.customer_id}<em class="string">, amount=$</em>#{order.amount}<em class="string">"</em></code></td>
    </tr>
  </table>

  <p id="N10F46">Sometimes these class-level methods return collections of objects:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.where(name: <em class="string">'dave'</em>).each <strong class="prompt">do</strong> |order|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts order.amount</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N10F64">Finally, the objects corresponding to individual rows in a table have methods that operate on that row. Probably the most widely used is <code class="cf methodname">save</code>, the operation that saves the row to the database:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.where(name: <em class="string">'dave'</em>).each <strong class="prompt">do</strong> |order|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.pay_type = <em class="string">"Purchase order"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N10F87">So, an ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects. Class methods are used to perform table-level operations, and instance methods perform operations on the individual rows.</p>

  <p id="N10F8A">In a typical ORM library, you supply configuration data to specify the mappings between entities in the database and entities in the program. Programmers using these ORM tools often find themselves creating and maintaining a boatload of XML configuration files.</p>

  <h3 id="heading_id_4">Active Record</h3>

  <p id="N10F91"><span class="emph">Active Record</span> is the ORM layer supplied with Rails. It closely follows the standard ORM model: tables map to classes, rows to objects, and columns to object attributes. It differs from most other ORM libraries in the way it is configured. By relying on convention and starting with sensible defaults, Active Record minimizes the amount of configuration that developers perform.</p>

  <p id="N10F9C">To illustrate this, here’s a program that uses Active Record to wrap our <code class="cf sqltable">orders</code> table:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">require <em class="string">'active_record'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Order &lt; ActiveRecord::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(1)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.pay_type = <em class="string">"Purchase order"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.save</code></td>
    </tr>
  </table>

  <p id="N10FC9">This code uses the new <code class="cf class">Order</code> class to fetch the order with an id of 1 and modify the pay_type. (We’ve omitted the code that creates a database connection for now.) Active Record relieves us of the hassles of dealing with the underlying database, leaving us free to work on business logic.</p>

  <p id="N10FCF">But Active Record does more than that. As you’ll see when we develop our shopping cart application, starting <a href="../Text/f_0039.html#chp.depot.start">​here​</a>, Active Record integrates seamlessly with the rest of the Rails framework. If a web form sends the application data related to a business object, Active Record can extract it into our model. Active Record supports sophisticated validation of model data, and if the form data fails validations, the Rails views can extract and format errors.</p>

  <p id="N10FD5">Active Record is the solid model foundation of the Rails MVC architecture.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
