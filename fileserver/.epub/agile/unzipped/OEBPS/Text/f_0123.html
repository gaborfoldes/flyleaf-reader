<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.fragment.caching">22.4 Fragment Caching</h2>

  <p id="N1DB2E">Caching parts of a page turns out to be remarkably useful in dynamic sites. Perhaps you customize the greeting and the sidebar on your blog application for each individual user. In this case, you can’t use page caching, because the overall page is different for each user. But because the list of articles doesn’t change between users, you can use fragment caching&mdash;you construct the HTML that displays the articles just once and include it in customized pages delivered to individual users.</p>

  <p id="N1DB47">Just to illustrate fragment caching, let’s set up a pretend blog application. Here’s the controller. It sets up <code class="cf variable">@dynamic_content</code>, representing content that should change each time the page is viewed. For our fake blog, we use the current time as this content.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/controllers/blog_controller.rb">rails31/e1/views/app/controllers/blog_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> BlogController &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> list</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@dynamic_content = Time.now.to_s</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1DB6D">Here’s our mock <code class="cf class">Article</code> class. It simulates a model class that in normal circumstances would fetch articles from the database. We’ve arranged for the first article in our list to display the time at which it was created.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/models/article.rb">rails31/e1/views/app/models/article.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Article</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">attr_reader :body</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> initialize(body)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@body = body</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> self.find_recent</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">[ new(<em class="string">"It is now</em> #{Time.now.to_s}<em class="string">"</em>),</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">new(<em class="string">"Today I had pizza"</em>),</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">new(<em class="string">"Yesterday I watched Spongebob"</em>),</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">new(<em class="string">"Did nothing on Saturday"</em>) ]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1DBC0">Now we’d like to set up a template that uses a cached version of the rendered articles but still updates the dynamic data. It turns out to be trivial.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/views/blog/list.html.erb">rails31/e1/views/app/views/blog/list.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;%= @dynamic_content %&gt; <em class="comment">&lt;!-- Here's dynamic content. --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% cache <strong class="prompt">do</strong> %&gt; <em class="comment">&lt;!-- Here's the content we cache --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">for</strong> article <strong class="prompt">in</strong> Article.find_recent %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;li&gt;</strong> <strong class="prompt">&lt;p&gt;</strong>&lt;%= h(article.body) %&gt;<strong class="prompt">&lt;/p&gt;</strong> <strong class="prompt">&lt;/li&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt; <em class="comment">&lt;!-- End of cached content --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;%= @dynamic_content %&gt; <em class="comment">&lt;!-- More dynamic content. --&gt;</em></code></td>
    </tr>
  </table>

  <p id="N1DC0F">The magic is the <code class="cf methodname">cache</code> method. All output generated in the block associated with this method will be cached. The next time this page is accessed, the dynamic content will still be rendered, but the stuff inside the block will come straight from the cache&mdash;it won’t be regenerated. We can see this if we bring up our skeletal application and hit Refresh after a few seconds, as shown in Figure 51, <a href="#fig.view.cache">​<em>Refreshing a page with cached and noncached data</em>​</a>. The times at the top and bottom of the page&mdash;the dynamic portion of our data&mdash;change on the refresh. However, the time in the center section remains the same, because it is being served from the cache. (If you’re trying this at home and you see all three time strings change, chances are you’re running your application in development mode. Caching is enabled by default only in production mode. If you’re testing using WEBrick, the <code class="cf commandname">-e&nbsp;production</code> option will do the trick.)</p>

  <p id="N1DC2F">The key concept here is that the stuff that’s cached is the fragment generated in the view. If we’d constructed the article list in the controller and then passed that list to the view, the future access to the page would not have to rerender the list, but the database would still be accessed on every request. Moving the database request into the view means it won’t be called once the output is cached.</p>

  <table class="figure" id="fig.view.cache">
    <tr>
      <td><img alt="images/view_cache.png" src="../Images/view_cache.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 51. Refreshing a page with cached and noncached data</b>
      </td>
    </tr>
  </table>

  <p id="N1DC3B">OK, you say, but that just broke the rule about putting application-level code into view templates. Can’t we avoid that somehow? We can, but it means making caching just a little less transparent than it would otherwise be. The trick is to have the action test for the presence of a cached fragment. If one exists, the action bypasses the expensive database operation, knowing that the fragment will be used.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/controllers/blog1_controller.rb">rails31/e1/views/app/controllers/blog1_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Blog1Controller &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> list</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@dynamic_content = Time.now.to_s</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">unless</strong> fragment_exist?(action: <em class="string">'list'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">logger.info(<em class="string">"Creating fragment"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@articles = Article.find_recent</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1DC79">The action uses the <code class="cf methodname">fragment_exist?</code> method to see whether a fragment exists for this action. If not, it loads the list of articles from the (fake) database. The view then uses this list to create the fragment.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/views/blog1/list.html.erb">rails31/e1/views/app/views/blog1/list.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;%= @dynamic_content %&gt; <em class="comment">&lt;!-- Here's dynamic content. --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% cache <strong class="prompt">do</strong> %&gt; <em class="comment">&lt;!-- Here's the content we cache --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">for</strong> article <strong class="prompt">in</strong> @articles %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;li&gt;</strong> <strong class="prompt">&lt;p&gt;</strong>&lt;%= h(article.body) %&gt;<strong class="prompt">&lt;/p&gt;</strong> <strong class="prompt">&lt;/li&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt; <em class="comment">&lt;!-- End of the cached content --&gt;</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;%= @dynamic_content %&gt; <em class="comment">&lt;!-- More dynamic content. --&gt;</em></code></td>
    </tr>
  </table>

  <h3 id="heading_id_2">Expiring Cached Fragments</h3>

  <p id="N1DCDA">Now that we have a cached version of the article list, our Rails application will be able to serve it whenever this page is referenced. If the articles are updated, however, the cached version will be out-of-date and should be expired. We do this with the <code class="cf methodname">expire_fragment</code> method. By default, fragments are cached using the name of the controller and action that rendered the page (<code class="cf ic">blog</code> and <code class="cf ic">list</code> in our first case). To expire the fragment (for example, when the article list changes), the controller could call this:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/controllers/blog_controller.rb">rails31/e1/views/app/controllers/blog_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expire_fragment(:controller =&gt; <em class="string">'blog'</em>, :action =&gt; <em class="string">'list'</em>)</code></td>
    </tr>
  </table>

  <p id="N1DD09">Clearly, this naming scheme works only if there’s just one fragment on the page. Fortunately, if you need more, you can override the names associated with fragments by adding parameters (using <code class="cf methodname">url_for</code> conventions) to the <code class="cf methodname">cache</code> method:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/views/blog2/list.html.erb">rails31/e1/views/app/views/blog2/list.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% cache(:action =&gt; <em class="string">'list'</em>, :part =&gt; <em class="string">'articles'</em>) <strong class="prompt">do</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">for</strong> article <strong class="prompt">in</strong> @articles %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;li&gt;</strong> <strong class="prompt">&lt;p&gt;</strong>&lt;%= h(article.body) %&gt;<strong class="prompt">&lt;/p&gt;</strong> <strong class="prompt">&lt;/li&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/ul&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% cache(:action =&gt; <em class="string">'list'</em>, :part =&gt; <em class="string">'counts'</em>) <strong class="prompt">do</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;p&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">There are a total of &lt;%= @article_count %&gt; articles.</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/p&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>
  </table>

  <p id="N1DD7E">In this example, two fragments are cached. The first has the additional <code class="cf ic">:part</code> parameter set to <code class="cf ic">articles</code>, and the second has it set to <code class="cf ic">counts</code>.</p>

  <p id="N1DD8A">Within the controller, we can pass the same parameters to <code class="cf methodname">expire_fragment</code> to delete particular fragments. For example, when we edit an article, we have to expire the article list, but the count is still valid. If instead we delete an article, we need to expire both fragments. The controller looks like this (we don’t have any code that actually does anything to the articles in it&mdash;just look at the caching):</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/views/app/controllers/blog2_controller.rb">rails31/e1/views/app/controllers/blog2_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Blog2Controller &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> list</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@dynamic_content = Time.now.to_s</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@articles = Article.find_recent</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@article_count = @articles.size</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> edit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># do the article editing</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expire_fragment(:action =&gt; <em class="string">'list'</em>, :part =&gt; <em class="string">'articles'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">redirect_to(:action =&gt; <em class="string">'list'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> delete</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># do the deleting</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expire_fragment(:action =&gt; <em class="string">'list'</em>, :part =&gt; <em class="string">'articles'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expire_fragment(:action =&gt; <em class="string">'list'</em>, :part =&gt; <em class="string">'counts'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">redirect_to(:action =&gt; <em class="string">'list'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1DE0E">The <code class="cf methodname">expire_fragment</code> method can also take a single regular expression as a parameter, allowing us to expire all fragments whose names match:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">expire_fragment(%r{/blog2/list.*})</code></td>
    </tr>
  </table>

  <h3 id="heading_id_3">What We Just Did</h3>

  <p id="N1DE23">We explored three techniques that can be used to make your site respond faster.</p>

  <p id="N1DE42">We learned how to cache entire pages and thereby avoid all Ruby, Rails, and database overhead when processing requests that can be served by the cache. This is useful for high-traffic pages that require database access to produce and yet rarely change. The product catalog listings from the Depot application is a prime example of such a page.</p>

  <p id="N1DE45">We learned how to cache the results of controller actions, avoiding rendering and database overhead. This is useful in cases where we want to continue to have filters run, generally for authentication purposes. Along the way we covered both explicit and implicit mechanisms to force expiration of pages in the cache.</p>

  <p id="N1DE48">Finally, we learned how to cache fragments of pages, which allows us full control over balancing optimization and the production of dynamic content.</p>

  <p id="N1DE4B">This covers maintaining the cache in support of views. Next up: maintaining database schemas in support of models.</p>

  <div class="footnotes">
    <h4 id="heading_id_4">Footnotes</h4>

    <table cellspacing="3">
      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0120.html#FNPTR-52" id="FOOTNOTE-52">[52]</a></td>

        <td>
          <p id="N1D613"><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9.3</a></p>
        </td>
      </tr>
    </table>
  </div>

  <div class="copyright">
    Copyright © 2011, The Pragmatic Bookshelf.
  </div><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
