<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">16.3 Iteration K3: Checking Up on a Deployed Application</h2>

  <p id="N18672">Once we have our application deployed, we’ll no doubt need to check up on how it’s running from time to time. We can do this in two primary ways. The first is to monitor the various log files output by both our front-end web server and the Apache server running our application. The second is to connect to our application using <code class="cf filename">rails console</code>.</p>

  <h3 id="heading_id_3">Looking at Log Files</h3>

  <p id="N1867C">To get a quick look at what’s happening in our application, we can use the <code class="cf filename">tail</code> command to examine log files as requests are made against our application. The most interesting data will usually be in the log files from the application itself. Even if Apache is running multiple applications, the logged output for each application is placed in the <code class="cf filename">production.log</code> file for that application.</p>

  <p id="N1868B">Assuming that our application is deployed into the location we showed earlier, here’s how we look at our running log file:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"># On your server</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">$ <strong class="prompt">cd /home/rubys/work/depot/</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">$ <strong class="prompt">tail -f log/production.log</strong></code></td>
    </tr>
  </table>

  <p id="N186AB">Sometimes, we need lower-level information&mdash;what’s going on with the data in our application? When this is the case, it’s time to break out the most useful live server debugging tool.</p>

  <h3 id="heading_id_4">Using Console to Look at a Live Application</h3>

  <p id="N186B2">We’ve already created a large amount of functionality in our application’s model classes. Of course, we created these to be used by our application’s controllers. But we can also interact with them directly. The gateway to this world is the <code class="cf filename">rails console</code> script. We can launch it on our server with this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"># On your server</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">$ <strong class="prompt">cd /home/rubys/work/depot/</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">$ <strong class="prompt">rails console production</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Loading production environment.</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">irb(main):001:0&gt; p = Product.find_by_title("Pragmatic Version Control")</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">=&gt; #&lt;Product:0x24797b4 @attributes={. . .}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">irb(main):002:0&gt; p.price = 32.95</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">=&gt; 32.95</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">irb(main):003:0&gt; p.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">=&gt; true</code></td>
    </tr>
  </table>

  <p id="N186F2">Once we have a console session open, we can poke and prod all the various methods on our models. We can create, inspect, and delete records. In a way, it’s like having a root console to your application.</p>

  <p id="N186F5">Once you put an application into production, we need to take care of a few chores to keep your application running smoothly. These chores aren’t automatically taken care of for us, but, luckily, we can automate them.</p>

  <h3 id="sec.log.files">Dealing with Log Files</h3>

  <p id="N186FD">As an application runs, it will constantly add data to its log file. Eventually, the log files can grow extremely large. To overcome this, most logging solutions can <span class="emph">roll over</span> log files to create a progressive set of log files of increasing age. This will break up our log files into manageable chunks that can be archived or even deleted after a certain amount of time has passed.</p>

  <p id="N18709">The <code class="cf class">Logger</code> class supports rollover. We need to specify how many (or how often) log files we want and the size of each, using a line like one of the following in the file <code class="cf filename">config/environments/production.rb</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">config.logger = Logger.new(config.paths[<em class="string">'log'</em>].first, <em class="string">'daily'</em>)</code></td>
    </tr>
  </table>

  <p id="N18723">Or perhaps this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">require <em class="string">'active_support/core_ext/numeric/bytes'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">config.logger = Logger.new(config.paths[<em class="string">'log'</em>].first, 10, 10.megabytes)</code></td>
    </tr>
  </table>

  <p id="N18739">Note that in this case an explicit require of <code class="cf ic">active_support</code> is needed because this statement is processed early in the initialization of your application&mdash;before the Active Support libraries have been included. In fact, one of the configuration options that Rails provides is to not include Active Support libraries at all:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">config.active_support.bare = true</code></td>
    </tr>
  </table>

  <p id="N1874A">Alternately, we can direct our logs to the system logs for our machine:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">config.logger = SyslogLogger.new</code></td>
    </tr>
  </table>

  <p id="N18758">Find more options at <a href="http://rubyonrails.org/deploy">http://rubyonrails.org/deploy</a>.</p>

  <h3 id="heading_id_5">Moving On to Launch and Beyond</h3>

  <p id="N18762">Once we’ve set up our initial deployment, we’re ready to finish the development of our application and launch it into production. We’ll likely set up additional deployment servers, and the lessons we learn from our first deployment will tell us a lot about how we should structure later deployments. For example, we’ll likely find that Rails is one of the slower components of our system&mdash;more of the request time will be spent in Rails than in waiting on the database or filesystem. This indicates that the way to scale up is to add machines to split up the Rails load across.</p>

  <p id="N1876B">However, we might find that the bulk of the time a request takes is in the database. If this is the case, we’ll want to look at how to optimize our database activity. Maybe we’ll want to change how we access data. Or maybe we’ll need to custom craft some SQL to replace the default Active Record behaviors.</p>

  <p id="N1876E">One thing is for sure: every application will require a different set of tweaks over its lifetime. The most important activity to do is to listen to it over time and discover what needs to be done. Our job isn’t done when we launch our application. It’s actually just starting.</p>

  <p id="N18781">While our job is just starting when we first deploy our application to production, we have completed our tour of the Depot application. After we recap what we did in this chapter, let’s look back at what we have accomplished in remarkably few lines of code.</p>

  <h3 id="heading_id_6">What We Just Did</h3>

  <p id="N18788">We covered a lot of ground in this chapter. We took our code that ran locally on our development machine for a single user and placed it on a different machine, running a different web server, accessing a different database, and possibly even running a different operating system.</p>

  <p id="N1878B">To accomplish this, we used a number of different products:</p>

  <ul>
    <li>
      <p id="N18791">We installed and configured Phusion Passenger and Apache httpd, a production-quality web server.</p>
    </li>

    <li>
      <p id="N18795">We installed and configured MySQL, a production-quality database server.</p>
    </li>

    <li>
      <p id="N18799">We got our application’s dependencies under control using Bundler and Git.</p>
    </li>

    <li>
      <p id="N1879D">We installed and configured Capistrano, which enables us to confidently and repeatably deploy our application.</p>
    </li>
  </ul>

  <h3 id="heading_id_7">Playtime</h3>

  <p id="N187A4">Here’s some stuff to try on your own:</p>

  <ul>
    <li>
      <p id="N187AA">If we have multiple developers collaborating on development, we might feel uncomfortable putting the details of the configuration of our database (potentially including passwords!) into our configuration management system. To address this, copy the completed <code class="cf filename">database.yml</code> into the <code class="cf dir">shared</code> directory, and write a task instructing Capistrano to copy this file into your <code class="cf dir">current</code> directory each time you deploy.</p>
    </li>
  </ul>

  <div class="footnotes">
    <h4 id="heading_id_8">Footnotes</h4>

    <table cellspacing="3">
      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0092.html#FNPTR-32" id="FOOTNOTE-32">[32]</a></td>

        <td>
          <p id="N180CF"><a href="http://www.sqlite.org/whentouse.html">http://www.sqlite.org/whentouse.html</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0092.html#FNPTR-33" id="FOOTNOTE-33">[33]</a></td>

        <td>
          <p id="N180ED"><a href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a></p>
        </td>
      </tr>

      <tr valign="top">
        <td class="footnote-number"><a href="../Text/f_0093.html#FNPTR-34" id="FOOTNOTE-34">[34]</a></td>

        <td>
          <p id="N185CF"><a href="http://beginrescueend.com/integration/capistrano/">http://beginrescueend.com/integration/capistrano/</a></p>
        </td>
      </tr>
    </table>
  </div>

  <div class="copyright">
    Copyright © 2011, The Pragmatic Bookshelf.
  </div><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
