<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">23.2 Anatomy of a Migration</h2>

  <p id="N1DFC7">Migrations are subclasses of the Rails class <code class="cf class">ActiveRecord::Migration</code>. Migrations generally contain the two methods <code class="cf methodname">up</code> and <code class="cf methodname">down</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> SomeMeaningfulName &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> up</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> down</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E01D">The name of the class, after all uppercase letters are downcased and preceded by an underscore, must match the portion of the filename after the version number. For example, the previous class could be found in a file named <code class="cf filename">20110711000017_some_meaningful_name.rb</code>. No two migrations can contain classes with the same name.</p>

  <p id="N1E023">The <code class="cf methodname">up</code> method is responsible for applying the schema changes for this migration, while the <code class="cf methodname">down</code> method undoes those changes. Let’s make this more concrete. Here’s a migration that adds an <code class="cf sqlcolumn">e_mail</code> column to the <code class="cf sqltable">orders</code> table:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> AddEmailToOrders &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> up</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :e_mail, :string</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> down</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">remove_column :orders, :e_mail</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E089">See how the <code class="cf methodname">down</code> method undoes the effect of the <code class="cf methodname">up</code> method?</p>

  <p id="N1E092">You can also see that there is a bit of duplication here. In many cases, Rails can detect how to automatically undo a given operation. For example, the opposite of <code class="cf methodname">add_column</code> is clearly <code class="cf methodname">remove_column</code>. In such cases, by simply renaming <code class="cf methodname">up</code> to <code class="cf methodname">change</code>, you can eliminate the need for a <code class="cf methodname">down</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> AddEmailToOrders &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :e_mail, :string</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E0C3">Now isn’t that much cleaner?</p>

  <h3 id="heading_id_3">Column Types</h3>

  <p id="N1E0CA">The third parameter to <code class="cf ic">add_column</code> specifies the type of the database column. In the previous example, we specified that the <code class="cf sqlcolumn">e_mail</code> column has a type of <code class="cf ic">:string</code>. But just what does this mean? Databases typically don’t have column types of <code class="cf ic">:string</code>.</p>

  <p id="N1E0DF">Remember that Rails tries to make your application independent of the underlying database; you could develop using SQLite 3 and deploy to Postgres if you wanted, for example. But different databases use different names for the types of columns. If you used a SQLite 3 column type in a migration, that migration might not work if applied to a Postgres database. So, Rails migrations insulate you from the underlying database type systems by using logical types. If we’re migrating a SQLite 3 database, the <code class="cf ic">:string</code> type will create a column of type <code class="cf ic">varchar(255)</code>. On Postgres, the same migration adds a column with the type <code class="cf ic">char varying(255)</code>.</p>

  <p id="N1E0FE">The types supported by migrations are <code class="cf ic">:binary</code>, <code class="cf ic">:boolean</code>, <code class="cf ic">:date</code>, <code class="cf ic">:datetime</code>, <code class="cf ic">:decimal</code>, <code class="cf ic">:float</code>, <code class="cf ic">:integer</code>, <code class="cf ic">:string</code>, <code class="cf ic">:text</code>, <code class="cf ic">:time</code>, and <code class="cf ic">:timestamp</code>. The default mappings of these types for the database adapters in Rails are shown in Figure 52, <a href="#fig.migration.types">​<em>Migration and database column types</em>​</a>. Using this figure, you could work out that a column declared to be <code class="cf ic">:integer</code> in a migration would have the underlying type <code class="cf ic">integer</code> in SQLite 3 and <code class="cf ic">number(38)</code> in Oracle.</p>

  <table class="figure" id="fig.migration.types">
    <tr>
      <td><img alt="images/migration_types.png" src="../Images/migration_types.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 52. Migration and database column types</b>
      </td>
    </tr>
  </table>

  <p id="N1E141">You can specify up to three options when defining most columns in a migration; decimal columns take an additional two options. Each of these options is given as a <code class="cf ic">key: value</code> pair. The common options are as follows:</p>

  <dl>
    <dt class="force-newline"><code class="cf ic">null: true</code>&nbsp;or&nbsp;<code class="cf ic">false</code></dt>

    <dd>
      <p id="N1E151">If <code class="cf ic">false</code>, the underlying column has a <code class="cf ic">not null</code> constraint added (if the database supports it).</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">limit: size</code></dt>

    <dd>
      <p id="N1E160">This sets a limit on the size of the field. This basically appends the string <code class="cf ic">(</code> <span class="emph">size</span> <code class="cf ic">)</code> to the database column type definition.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">default: value</code></dt>

    <dd>
      <p id="N1E170">This sets the default value for the column. Note that the default is calculated once, at the point the migration is run, so the following code will set the default column value to the date and time when the migration was run:</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">add_column :orders, :placed_at, :datetime, default: Time.now</code></td>
        </tr>
      </table>
    </dd>
  </dl>

  <p id="N1E17E">In addition, decimal columns take the options <code class="cf ic">:precision</code> and <code class="cf ic">:scale</code>. The <code class="cf ic">:precision</code> option specifies the number of significant digits that will be stored, and the <code class="cf ic">:scale</code> option determines where the decimal point will be located in these digits (think of the scale as the number of digits after the decimal point). A decimal number with a precision of 5 and a scale of 0 can store numbers from -99,999 to +99,999. A decimal number with a precision of 5 and a scale of 2 can store the range -999.99 to +999.99.</p>

  <p id="N1E192">The <code class="cf ic">:precision</code> and <code class="cf ic">:scale</code> parameters are optional for decimal columns. However, incompatibilities between different databases lead us to strongly recommend that you include the options for each decimal column.</p>

  <p id="N1E19B">Here are some column definitions using the migration types and options:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :attn, :string, limit: 100</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :order_type, :integer</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :ship_class, :string, null: false, default: <em class="string">'priority'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">add_column :orders, :amount, :decimal, precision: 8, scale: 2</code></td>
    </tr>
  </table>

  <h3 id="heading_id_4">Renaming Columns</h3>

  <p id="N1E1B8">When we refactor our code, we often change our variable names to make them more meaningful. Rails migrations allow us to do this to database column names, too. For example, a week after we first added it, we might decide that <code class="cf sqlcolumn">e_mail</code> isn’t the best name for the new column. We can create a migration to rename it using the <code class="cf methodname">rename_column</code> method:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> RenameEmailColumn &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> change</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">rename_column :orders, :e_mail, :customer_email</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E203">As <code class="cf methodname">rename_column</code> is reversible, separate <code class="cf methodname">up</code> and <code class="cf methodname">down</code> methods are not required in order to use it.</p>

  <p id="N1E20F">Note that the rename doesn’t destroy any existing data associated with the column. Also be aware that renaming is not supported by all the adapters.</p>

  <h3 id="heading_id_5">Changing Columns</h3>

  <p id="N1E216">Use the <code class="cf methodname">change_column</code> method to change the type of a column or to alter the options associated with a column. Use it the same way you’d use <code class="cf ic">add_column</code>, but specify the name of an existing column. Let’s say that the order type column is currently an integer, but we need to change it to be a string. We want to keep the existing data, so an order type of <code class="cf ic">123</code> will become the string <code class="cf ic">"123"</code>. Later, we’ll use noninteger values such as <code class="cf ic">"new"</code> and <code class="cf ic">"existing"</code>.</p>

  <p id="N1E23C">Changing from an integer column to a string is easy:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> up</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">change_column :orders, :order_type, :string</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E254">However, the opposite transformation is problematic. We might be tempted to write the obvious <code class="cf methodname">down</code> migration:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> down</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">change_column :orders, :order_type, :integer</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E26E">But if our application has taken to storing data like <code class="cf ic">"new"</code> in this column, the <code class="cf methodname">down</code> method will lose it&mdash;<code class="cf ic">"new"</code> can’t be converted to an integer. If that’s acceptable, then the migration is acceptable as it stands. If, however, we want to create a one-way migration&mdash;one that cannot be reversed&mdash;we’ll want to stop the down migration from being applied. In this case, Rails provides a special exception that we can throw:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> ChangeOrderTypeToString &lt; ActiveRecord::Migration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> up</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">change_column :orders, :order_type, :string, null: false</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> down</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">raise ActiveRecord::IrreversibleMigration</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1E2B7"><code class="cf ic">ActiveRecord::IrreversibleMigration</code> is also the name of the exception that Rails will raise if you attempt to call a method that can’t be automatically reversed from within a <code class="cf methodname">change</code> method.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
