<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">23.1 Creating and Running Migrations</h2>

  <p id="N1DE8B">A migration is simply a Ruby source file in your application’s <code class="cf dir">db/migrate</code> directory. Each migration file’s name starts with a number of digits (typically fourteen) and an underscore. Those digits are the key to migrations, because they define the sequence in which the migrations are applied&mdash;they are the individual migration’s version number.</p>

  <p id="N1DE97">The version number itself is the Coordinated Universal Time (UTC) timestamp at the time the migration was created. These numbers contain the four-digit year, followed by two digits each for the month, day, hour, minute, and second, all based on the mean solar time at the Royal Observatory in Greenwich, London. Because migrations tend to be created relatively infrequently and the accuracy is recorded down to the second, the chances of any two people getting the same timestamp is vanishingly small. And the benefit of having timestamps that can be deterministically ordered far outweighs the miniscule risk of this occurring.</p>

  <p id="N1DE9A">Here’s what the <code class="cf dir">db/migrate</code> directory of our Depot application looks like:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">ls db/migrate</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000001_create_products.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000002_create_carts.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000003_create_line_items.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000004_add_quantity_to_line_items.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000005_combine_items_in_cart.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000006_create_orders.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000007_add_order_id_to_line_item.rb</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">20110711000008_create_users.rb</code></td>
    </tr>
  </table>

  <p id="N1DEC6">Although you could create these migration files by hand, it’s easier (and less error prone) to use a generator. As we saw when we created the Depot application, there are actually two generators that create migration files:</p>

  <ul>
    <li>
      <p id="N1DED2">The <span class="emph">model</span> generator creates a migration to in turn create the table associated with the model (unless you specify the <code class="cf ic">--skip-migration</code> option). As the example that follows shows, creating a model called <code class="cf ic">discount</code> also creates a migration called <span class="emph">yyyyMMddhhmmss_</span> <code class="cf ic">create_discounts.rb</code>:</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rails generate model discount</strong></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">invoke active_record</code></td>
        </tr>

        <tr>
          <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

          <td class="codeline"><code class="sgc-1">create db/migrate/20110608133549_create_discounts.rb</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">create app/models/discount.rb</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">invoke test_unit</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">create test/unit/discount_test.rb</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">create test/fixtures/discounts.yml</code></td>
        </tr>
      </table>
    </li>

    <li>
      <p id="N1DF0C">You can also generate a migration on its own:</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rails generate migration add_price_column</strong></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">invoke active_record</code></td>
        </tr>

        <tr>
          <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

          <td class="codeline"><code class="sgc-1">create db/migrate/20110608133814_add_price_column.rb</code></td>
        </tr>
      </table>
    </li>
  </ul>

  <p id="N1DF2B">Later, starting in <span class="emph">Anatomy of a Migration</span>, we’ll see what goes in the migration files. But for now, let’s jump ahead a little in the workflow and see how to run migrations.</p>

  <h3 id="heading_id_3">Running Migrations</h3>

  <p id="N1DF35">Migrations are run using the <code class="cf ic">db:migrate</code> Rake task:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rake db:migrate</strong></code></td>
    </tr>
  </table>

  <p id="N1DF59">To see what happens next, let’s dive down into the internals of Rails.</p>

  <p id="N1DF5C">The migration code maintains a table called <code class="cf sqltable">schema_migrations</code> inside every Rails database. This table has just one column, called <code class="cf sqlcolumn">version</code>, and it will have one row per successfully applied migration.</p>

  <p id="N1DF65">When you run <code class="cf ic">rake db:migrate</code>, the task first looks for the <code class="cf sqltable">schema_migrations</code> table. If it doesn’t yet exist, it will be created.</p>

  <p id="N1DF6E">The migration code then looks at all the migration files in <code class="cf dir">db/migrate</code> and skips from consideration any that have a version number (the leading digits in the filename) that is already in the database. It then proceeds to apply the remainder of the migrations, creating a row in the <code class="cf sqltable">schema_migrations</code> table for each.</p>

  <p id="N1DF77">If we were to run migrations again at this point, nothing much would happen. Each of the version numbers of the migration files would match with a row in the database, so there’d be no migrations to apply.</p>

  <p id="N1DF7A">However, if we subsequently create a new migration file, it will have a version number not in the database. This is true even if the version number was <span class="emph">before</span> one or more of the already applied migrations. This can happen when multiple users are using a version control system to store the migration files. If we then run migrations, this new migration file&mdash;and only this migration file&mdash;will be executed. This may mean that migrations are run out of order, so you might want to take care and ensure that these migrations are independent. Or you might want to revert your database to a previous state and then apply the migrations in order.</p>

  <p id="N1DF80">You can force the database to a specific version by supplying the <code class="cf ic">VERSION=</code> parameter to the <code class="cf ic">rake db:migrate</code> command:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rake db:migrate VERSION=20110711000009</strong></code></td>
    </tr>
  </table>

  <p id="N1DF97">If the version you give is greater than any of the migrations that have yet to be applied, these migrations will be applied.</p>

  <p id="N1DF9A">If, however, the version number on the command line is less than one or more versions listed in the <code class="cf sqltable">schema_migrations</code> table, something different happens. In these circumstances, Rails looks for the migration file whose number matches the database version and <span class="emph">undoes</span> it. It repeats this process until there are no more versions listed in the <code class="cf sqltable">schema_migrations</code> table that exceed the number you specified on the command line. That is, the migrations are unapplied in reverse order to take the schema back to the version that you specify.</p>

  <p id="N1DFAC">You can also redo one or more migrations:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">depot&gt; <strong class="prompt">rake db:migrate:redo STEP=3</strong></code></td>
    </tr>
  </table>

  <p id="N1DFBD">By default, redo will roll back one migration and rerun it. To roll back multiple migrations, pass the <code class="cf ic">STEP=</code> parameter.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
