<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">4.2 Data Types</h2>

  <p id="N111F2">While everything in Ruby is an object, some of the data types in Ruby have special syntax support, in particular for defining literal values. In these examples, we’ve used some simple strings and even string concatenation.</p>

  <h3 id="heading_id_3">Strings</h3>

  <p id="N11207">This previous example also showed some Ruby string objects. One way to create a string object is to use <span class="firstuseinline">string literals</span>, which are sequences of characters between single or double quotation marks. The difference between the two forms is the amount of processing Ruby does on the string while constructing the literal. In the single-quoted case, Ruby does very little. With a few exceptions, what you type into the single-quoted string literal becomes the string’s value.</p>

  <p id="N11219">In the double-quoted case, Ruby does more work. First, it looks for <span class="firstuseinline">substitutions</span>&mdash;sequences that start with a backslash character&mdash;and replaces them with some binary value. The most common of these is <code class="cf ic">\n</code>, which is replaced with a newline character. When you write a string containing a newline to the console, the <code class="cf ic">\n</code> forces a line break.</p>

  <p id="wtf.interpolation">Second, Ruby performs <span class="firstuseinline">expression interpolation</span> in double-quoted strings. In the string, the sequence <code class="cf ic">#{</code> <span class="emph">expression</span> <code class="cf ic">}</code> is replaced by the value of <span class="emph">expression</span>. We could use this to rewrite our previous method:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> say_goodnight(name)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">"Good night,</em> #{name.capitalize}<em class="string">"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts say_goodnight(<em class="string">'pa'</em>)</code></td>
    </tr>
  </table>

  <p id="N1125D">When Ruby constructs this string object, it looks at the current value of <code class="cf variable">name</code> and substitutes it into the string. Arbitrarily complex expressions are allowed in the <code class="cf ic">#{…}</code> construct. Here we invoked the <code class="cf methodname">capitalize</code> method, defined for all strings, to output our parameter with a leading uppercase letter.</p>

  <p id="N11269">Strings are a fairly primitive data type that contain an ordered collection of bytes or characters. Ruby also provides means for defining collections of arbitrary objects via arrays and hashes.</p>

  <h3 id="wtf.hash">Arrays and Hashes</h3>

  <p id="N11271">Ruby’s arrays and hashes are indexed collections. Both store collections of objects, accessible using a key. With arrays, the key is an integer, whereas hashes support any object as a key. Both arrays and hashes grow as needed to hold new elements. It’s more efficient to access array elements, but hashes provide more flexibility. Any particular array or hash can hold objects of differing types; you can have an array containing an integer, a string, and a floating-point number, for example.</p>

  <p id="N11289">You can create and initialize a new array object using an <span class="firstuseinline">array literal</span>&mdash;a set of elements between square brackets. Given an array object, you can access individual elements by supplying an index between square brackets, as the next example shows. Ruby array indices start at zero.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">a = [ 1, <em class="string">'cat'</em>, 3.14 ] <em class="comment"># array with three elements</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">a[0] <em class="comment"># access the first element (1)</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">a[2] = nil <em class="comment"># set the third element</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># array now [ 1, 'cat', nil ]</em></code></td>
    </tr>
  </table>

  <p id="N112B8">You may have noticed that we used the special value <code class="cf constant">nil</code> in this example. In many languages, the concept of <span class="emph">nil</span> (or <span class="emph">null</span>) means “no object.” In Ruby, that’s not the case; <code class="cf constant">nil</code> is an object, just like any other, that happens to represent nothing.</p>

  <p id="wtf.append">The method <code class="cf methodname">&lt;&lt;</code> is commonly used with arrays. It appends a value to its receiver.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ages = []</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">for</strong> person <strong class="prompt">in</strong> @people</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ages &lt;&lt; person.age</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N112F3">Ruby has a shortcut for creating an array of words:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">a = [ <em class="string">'ant'</em>, <em class="string">'bee'</em>, <em class="string">'cat'</em>, <em class="string">'dog'</em>, <em class="string">'elk'</em> ]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># this is the same:</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">a = <em class="string">%w{ ant bee cat dog elk }</em></code></td>
    </tr>
  </table>

  <p id="N1131D">Ruby hashes are similar to arrays. A hash literal uses braces rather than square brackets. The literal must supply two objects for every entry: one for the key, the other for the value. For example, you may want to map musical instruments to their orchestral sections:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">inst_section = {</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:cello =&gt; <em class="string">'string'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:clarinet =&gt; <em class="string">'woodwind'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:drum =&gt; <em class="string">'percussion'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:oboe =&gt; <em class="string">'woodwind'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:trumpet =&gt; <em class="string">'brass'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">:violin =&gt; <em class="string">'string'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">}</code></td>
    </tr>
  </table>

  <p id="N1135B">The thing to the left of the <code class="cf ic">=&gt;</code> is the key, and that on the right is the corresponding value. Keys in a particular hash must be unique&mdash;you can’t have two entries for <code class="cf ic">:drum</code>. The keys and values in a hash can be arbitrary objects&mdash;you can have hashes where the values are arrays, other hashes, and so on. In Rails, hashes typically use symbols as keys. Many Rails hashes have been subtly modified so that you can use either a string or a symbol interchangeably as a key when inserting and looking up values.</p>

  <p id="N11368">Use of symbols as hash keys is so commonplace that starting with Ruby 1.9 there is a special syntax for it, saving both keystrokes and eyestrain.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">inst_section = {</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">cello: <em class="string">'string'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">clarinet: <em class="string">'woodwind'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">drum: <em class="string">'percussion'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">oboe: <em class="string">'woodwind'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">trumpet: <em class="string">'brass'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">violin: <em class="string">'string'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">}</code></td>
    </tr>
  </table>

  <p id="N1139C">Doesn’t that look much better?</p>

  <p id="N1139F">Feel free to use whichever syntax you like. You can even intermix usages in a single expression. Obviously you’ll need to use the arrow syntax whenever the key is <span class="emph">not</span> a symbol, or if you are using Ruby 1.8.7. However, most developers seem to prefer the new syntax, and Rails will even generate scaffolds using the new syntax if it detects that you are running Rails 1.9.2.</p>

  <p id="N113A5">Hashes are indexed using the same square bracket notation as arrays:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">inst_section[:oboe] <em class="comment">#=&gt; 'woodwind'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">inst_section[:cello] <em class="comment">#=&gt; 'string'</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">inst_section[:bassoon] <em class="comment">#=&gt; nil</em></code></td>
    </tr>
  </table>

  <p id="N113C3">As the previous example shows, a hash returns <code class="cf constant">nil</code> when indexed by a key it doesn’t contain. Normally this is convenient, because <code class="cf constant">nil</code> means false when used in conditional expressions.</p>

  <p id="N113CC">You can pass hashes as parameters on method calls. Ruby allows you to omit the braces, but only if the hash is the last parameter of the call. Rails makes extensive use of this feature. The following code fragment shows a two-element hash being passed to the <code class="cf methodname">redirect_to</code> method. In effect, though, you can ignore that it’s a hash and pretend that Ruby has keyword arguments.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">redirect_to action: <em class="string">'show'</em>, id: product.id</code></td>
    </tr>
  </table>

  <p id="N113E0">There is one more data type worth mentioning&mdash;the regular expression.</p>

  <h3 id="wtf.regexp">Regular Expressions</h3>

  <p id="N113FA">A regular expression lets you specify a <span class="emph">pattern</span> of characters to be matched in a string. In Ruby, you typically create a regular expression by writing <code class="cf ic">/<span class="emph">pattern</span>/</code> or <code class="cf ic">%r{<span class="emph">pattern</span>}</code>.</p>

  <p id="N11418">For example, you could write a pattern that matches a string containing the text <span class="emph">Perl</span> or the text <span class="emph">Python</span> using the regular expression <code class="cf ic">/Perl|Python/</code>.</p>

  <p id="N11424">The forward slashes delimit the pattern, which consists of the two things we’re matching, separated by a vertical bar (<code class="cf ic">|</code>). This bar character means “either the thing on the left or the thing on the right,” in this case either <span class="emph">Perl</span> or <span class="emph">Python</span>. You can use parentheses within patterns, just as you can in arithmetic expressions, so you could also have written this pattern as <code class="cf ic">/P(erl|ython)/</code>. Programs typically test strings against regular expressions using the <code class="cf ic">=~</code> match operator:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> line =~ /P(erl|ython)/</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts <em class="string">"There seems to be another scripting language here"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N11454">You can specify <span class="emph">repetition</span> within patterns. <code class="cf ic">/ab+c/</code> matches a string containing an <span class="emph">a</span> followed by one or more <span class="emph">b</span>’s, followed by a <span class="emph">c</span>. Change the plus to an asterisk, and <code class="cf ic">/ab*c/</code> creates a regular expression that matches one <span class="emph">a</span>, zero or more <span class="emph">b</span>’s, and one <span class="emph">c</span>.</p>

  <p id="N11472">Backward slashes start special sequences; most notably, <code class="cf ic">\d</code> matches any digit, <code class="cf ic">\s</code> matches any whitespace character, and <code class="cf ic">\w</code> matches any alphanumeric ("word") character.</p>

  <p id="N1147E">Ruby’s regular expressions are a deep and complex subject; this section barely skims the surface. See the PickAxe book for a full discussion.</p>

  <p id="N11481">This book will only make light use of regular expressions.</p>

  <p id="N11484">With that brief introduction to data, let’s move on to logic.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
