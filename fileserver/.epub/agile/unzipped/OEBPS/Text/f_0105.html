<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">19.3 Creating, Reading, Updating, and Deleting (CRUD)</h2>

  <p id="N195CD">Names such as SQLite and MySQL emphasize that all access to a database is via the Structured Query Language (SQL). In most cases, Rails will take care of this for you, but that is completely up to you. As you will see, you can provide clauses or even entire SQL statements for the database to execute.</p>

  <p id="N195D0">If you are familiar with SQL already, as you read this section take note of how Rails provides places for familiar clauses such as <code class="cf ic">select</code>, <code class="cf ic">from</code>, <code class="cf ic">where</code>, <code class="cf ic">group by</code>, and so on. If you are not already familiar with SQL, one of the strengths of Rails is that you can defer knowing more about such things until you actually need to access the database at this level.</p>

  <p id="N195DF">In this section, we’ll continue to work with the <code class="cf class">Order</code> model from the Depot application for an example. We will be using Active Record methods to apply the four basic database operations: create, read, update, and delete.</p>

  <h3 id="heading_id_3">Creating New Rows</h3>

  <p id="N195ED">Given that Rails represents tables as classes and rows as objects, it follows that we create rows in a table by creating new objects of the appropriate class. We can create new objects representing rows in our <code class="cf sqltable">orders</code> table by calling <code class="cf methodname">Order.new</code>. We can then fill in the values of the attributes (corresponding to columns in the database). Finally, we call the object’s <code class="cf methodname">save</code> method to store the order back into the database. Without this call, the order would exist only in our local memory.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order = Order.new</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.name = <em class="string">"Dave Thomas"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.email = <em class="string">"dave@example.com"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.address = <em class="string">"123 Main St"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.pay_type = <em class="string">"check"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.save</code></td>
    </tr>
  </table>

  <p id="N19634">Active Record constructors take an optional block. If present, the block is invoked with the newly created order as a parameter. This might be useful if you wanted to create and save away an order without creating a new local variable.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.new <strong class="prompt">do</strong> |o|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">o.name = <em class="string">"Dave Thomas"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># . . .</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">o.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19657">Finally, Active Record constructors accept a hash of attribute values as an optional parameter. Each entry in this hash corresponds to the name and value of an attribute to be set. This is useful for doing things like storing values from HTML forms into database rows.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order = Order.new(</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">name: <em class="string">"Dave Thomas"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">email: <em class="string">"dave@example.com"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">address: <em class="string">"123 Main St"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: <em class="string">"check"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.save</code></td>
    </tr>
  </table>

  <p id="N19681">Note that in all of these examples we did not set the <code class="cf sqlcolumn">id</code> attribute of the new row. Because we used the Active Record default of an integer column for the primary key, Active Record automatically creates a unique value and sets the <code class="cf sqlcolumn">id</code> attribute as the row is saved. We can subsequently find this value by querying the attribute.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order = Order.new</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.name = <em class="string">"Dave Thomas"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ...</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts <em class="string">"The ID of this order is</em> #{an_order.id}<em class="string">"</em></code></td>
    </tr>
  </table>

  <p id="N196AA">The <code class="cf methodname">new</code> constructor creates a new <code class="cf class">Order</code> object in memory; we have to remember to save it to the database at some point. Active Record has a convenience method, <code class="cf methodname">create</code>, that both instantiates the model object and stores it into the database.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order = Order.create(</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">name: <em class="string">"Dave Thomas"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">email: <em class="string">"dave@example.com"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">address: <em class="string">"123 Main St"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: <em class="string">"check"</em>)</code></td>
    </tr>
  </table>

  <p id="N196E5">You can pass <code class="cf methodname">create</code> an array of attribute hashes; it’ll create multiple rows in the database and return an array of the corresponding model objects:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/new_examples.rb">rails31/e1/ar/new_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.create(</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">[ { name: <em class="string">"Dave Thomas"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">email: <em class="string">"dave@example.com"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">address: <em class="string">"123 Main St"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: <em class="string">"check"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">},</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{ name: <em class="string">"Andy Hunt"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">email: <em class="string">"andy@example.com"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">address: <em class="string">"456 Gentle Drive"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: <em class="string">"po"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">} ] )</code></td>
    </tr>
  </table>

  <p id="N1972B">The <span class="emph">real</span> reason that <code class="cf methodname">new</code> and <code class="cf methodname">create</code> take a hash of values is that you can construct model objects directly from form parameters:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@order = Order.new(params[:order])</code></td>
    </tr>
  </table>

  <p id="N19742">If you think this line looks familiar, it is because you have seen it before. It appears in <code class="cf filename">orders_controller.rb</code> in the Depot application.</p>

  <h3 id="heading_id_4">Reading Existing Rows</h3>

  <p id="N19759">Reading from a database involves first specifying which particular rows of data you are interested in&mdash;you’ll give Active Record some kind of criteria, and it will return objects containing data from the row(s) matching the criteria.</p>

  <p id="N19763">The simplest way of finding a row in a table is by specifying its primary key. Every model class supports the <code class="cf methodname">find</code> method, which takes one or more primary key values. If given just one primary key, it returns an object containing data for the corresponding row (or throws a <code class="cf class">ActiveRecord::RecordNotFound</code> exception). If given multiple primary key values, <code class="cf methodname">find</code> returns an array of the corresponding objects. Note that in this case a <code class="cf class">RecordNotFound</code> exception is raised if <span class="emph">any</span> of the ids cannot be found (so if the method returns without raising an error, the length of the resulting array will be equal to the number of ids passed as parameters):</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">an_order = Order.find(27) <em class="comment"># find the order with id == 27</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># Get a list of product ids from a form, then</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># sum the total price</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">product_list = params[:product_ids]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">total = Product.find(product_list).sum(&amp;:price)</code></td>
    </tr>
  </table>

  <div class="xxxsays">
    <div class="heading">
      <div class="persons-picture"><img alt="David says:" src="../Images/David.png" /></div>

      <div class="label">
        David says:
      </div>

      <div class="title">
        To Raise, or Not to Raise?
      </div>
    </div>

    <div class="body">
      <p id="N197AF">When you use a finder driven by primary keys, you’re looking for a particular record. You expect it to exist. A call to <code class="cf ic">Person.find(5)</code> is based on our knowledge of the <code class="cf sqltable">people</code> table. We want the row with an id of 5. If this call is unsuccessful&mdash;if the record with the id of 5 has been destroyed&mdash;we’re in an exceptional situation. This mandates the raising of an exception, so Rails raises <code class="cf class">RecordNotFound</code>.</p>

      <p id="N197BB">On the other hand, finders that use criteria to search are looking for a <span class="emph">match</span>. So, <code class="cf ic">Person.where(name: ’Dave’).first</code> is the equivalent of telling the database (as a black box) “Give me the first person row that has the name Dave.” This exhibits a distinctly different approach to retrieval; we’re not certain up front that we’ll get a result. It’s entirely possible the result set may be empty. Thus, returning <code class="cf constant">nil</code> in the case of finders that search for one row and an empty array for finders that search for many rows is the natural, nonexceptional response.</p>
    </div>
  </div>

  <p id="N197CD">Often, though, you need to read in rows based on criteria other than their primary key value. Active Record provides a range of options for performing these queries. We’ll start by looking at an alternate way to express simple <code class="cf ic">where</code> clauses and then look at additional ways to modify the queries Rails generates for you.</p>

  <h4 id="sec.dynamic.finders">Dynamic Finders</h4>

  <p id="N197D8">Probably the most common search performed on databases is to return the row or rows where a column matches a given value. A query might be <span class="emph">return all the orders for Dave</span> or <span class="emph">get all the blog postings with a subject of “Rails Rocks.”</span> In many other languages and frameworks, you’d construct SQL queries to perform these searches. Active Record uses Ruby’s dynamic power to do this for you.</p>

  <p id="N197EC">For example, our <code class="cf class">Order</code> model has attributes such as <code class="cf sqlcolumn">name</code>, <code class="cf sqlcolumn">email</code>, and <code class="cf sqlcolumn">address</code>. We can use these names in finder methods to return rows where the corresponding columns match some value:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/find_examples.rb">rails31/e1/ar/find_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find_by_name(<em class="string">"Dave Thomas"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.find_all_by_name(<em class="string">"Dave Thomas"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.find_all_by_email(params[<em class="string">'email'</em>])</code></td>
    </tr>
  </table>

  <p id="N19816">If you invoke a model’s class method where the method name starts <code class="cf methodname">find_by_</code>, <code class="cf methodname">find_last_by_</code>, or <code class="cf methodname">find_all_by_</code>, Active Record converts it to a finder, using the rest of the method’s name to determine the column to be checked. Thus, the call to this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find_by_name(<em class="string">"Dave Thomas"</em>)</code></td>
    </tr>
  </table>

  <p id="N19851">is (effectively) converted by Active Record into this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.where(name: <em class="string">"Dave Thomas"</em>).first</code></td>
    </tr>
  </table>

  <p id="N19862">Similarly, calls to <code class="cf ic">find_all_by</code>_<span class="emph">xxx</span> and to <code class="cf ic">find_last_by</code>_<span class="emph">xxx</span> substitute calls to <code class="cf methodname">all</code> and <code class="cf methodname">last</code>, respectively, for the implicit call to <code class="cf methodname">first</code>.</p>

  <p id="N1987A">Appending a bang (<code class="cf ic">!</code>) character to the <code class="cf ic">find_by_</code> call will cause a <code class="cf ic">ActiveRecord::</code> <code class="cf ic">RecordNotFound</code> exception to be raised instead of returning <code class="cf constant">nil</code> if it can’t find a matching record:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find_by_name!(<em class="string">"Dave Thomas"</em>)</code></td>
    </tr>
  </table>

  <p id="N19899">The magic doesn’t stop there. Active Record will also create finders that search on multiple columns. For example, you could write this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">user = User.find_by_name_and_password(name, pw)</code></td>
    </tr>
  </table>

  <p id="N198A7">This is equivalent to the following:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">user = User.where(name: name, password: pw).first</code></td>
    </tr>
  </table>

  <p id="N198B5">To determine the names of the columns to check, Active Record simply splits the name that follows the <code class="cf ic">find_by_</code> or <code class="cf ic">find_all_by_</code> around the string <code class="cf ic">_and_</code>. This is good enough most of the time but breaks down if you ever have a column name such as <code class="cf sqlcolumn">tax_and_shipping</code>. In these cases, you’ll have to use other methods to construct the <code class="cf ic">where</code> clause.</p>

  <p id="N198C7">There are times when you want to ensure you always have a model object to work with. If there isn’t one in the database, you want to create one. Dynamic finders can handle this. Calling a method whose name starts <code class="cf methodname">find_or_initialize_by_</code> or <code class="cf methodname">find_or_create_by_</code> will call either <code class="cf methodname">new</code> or <code class="cf methodname">create</code> on the model class if the finder would otherwise return <code class="cf constant">nil</code>. The new model object will be initialized so that its attributes corresponding to the finder criteria have the values passed to the finder method, and it will have been saved to the database if the <code class="cf ic">create</code> variant is used.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">cart = Cart.find_or_initialize_by_user_id(user.id)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">cart.items &lt;&lt; new_item</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">cart.save</code></td>
    </tr>
  </table>

  <p id="N19903">And, no, there isn’t a <code class="cf ic">find_by_</code> form that lets you use <code class="cf ic">_or_</code> rather than <code class="cf ic">_and_</code> between column names.</p>

  <h4 id="sec.find.placeholder">SQL and Active Record</h4>

  <p id="N19914">To illustrate how Active Record works with SQL, let’s pass a simple string to the <code class="cf methodname">where</code> method call corresponding to a SQL <code class="cf ic">where</code> clause. For example, to return a list of all orders for Dave with a payment type of “po,” we could use this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(<em class="string">"name = 'Dave' and pay_type = 'po'"</em>)</code></td>
    </tr>
  </table>

  <p id="N19937">The result will be an <code class="cf class">ActiveRecord::Relation</code> object containing all the matching rows, each neatly wrapped in an <code class="cf class">Order</code> object.</p>

  <p id="N19940">That’s fine if our condition is predefined, but how do we handle the situation where the name of the customer is set externally (perhaps coming from a web form)? One way is to substitute the value of that variable into the condition string:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># get the name from the form</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">name = params[:name]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># DON'T DO THIS!!!</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(<em class="string">"name = '</em>#{name}<em class="string">' and pay_type = 'po'"</em>)</code></td>
    </tr>
  </table>

  <p id="N1995F">As the comment suggests, this really isn’t a good idea. Why? It leaves the database wide open to something called a <span class="firstuseinline">SQL injection</span> attack, which we describe in more detail in the Rails Guides that you generated <a href="../Text/f_0100.html#p.rake.doc">​here​</a>. For now, take it as a given that substituting a string from an external source into a SQL statement is effectively the same as publishing your entire database to the whole online world.</p>

  <p id="N1996D">Instead, the safe way to generate dynamic SQL is to let Active Record handle it. Doing this allows Active Record to create properly escaped SQL, which is immune from SQL injection attacks. Let’s see how this works.</p>

  <p id="N19970">If we pass multiple parameters to a <code class="cf methodname">where</code> call, Rails treats the first parameter as a template for the SQL to generate. Within this SQL, we can embed placeholders, which will be replaced at runtime by the values in the rest of the array.</p>

  <p id="N19976">One way of specifying placeholders is to insert one or more question marks in the SQL. The first question mark is replaced by the second element of the array, the next question mark by the third, and so on. For example, we could rewrite the previous query as this:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">name = params[:name]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where([<em class="string">"name = ? and pay_type = 'po'"</em>, name])</code></td>
    </tr>
  </table>

  <p id="N1998A">We can also use named placeholders. We do that by placing placeholders of the form <code class="cf ic">:name</code> into the string and by providing corresponding values in a hash, where the keys correspond to the names in the query:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">name = params[:name]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type = params[:pay_type]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(<em class="string">"name = :name and pay_type = :pay_type"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: pay_type, name: name)</code></td>
    </tr>
  </table>

  <p id="N199A7">We can take this a step further. Because <code class="cf ic">params</code> is effectively a hash, we can simply pass it all to the condition. If we have a form that can be used to enter search criteria, we can use the hash of values returned from that form directly:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(<em class="string">"name = :name and pay_type = :pay_type"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">params[:order])</code></td>
    </tr>
  </table>

  <p id="N199D3">We can take this even further. If we pass just a hash as the condition, Rails generates a <code class="cf ic">where</code> clause using the hash keys as column names and the hash values as the values to match. Thus, we could have written the previous code even more succinctly:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(params[:order])</code></td>
    </tr>
  </table>

  <p id="N199E4">Be careful with this latter form of condition: it takes <span class="emph">all</span> the key/value pairs in the hash you pass in when constructing the condition. An alternative would be to specify which parameters to use explicitly:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pos = Order.where(name: params[:name],</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pay_type: params[:pay_type])</code></td>
    </tr>
  </table>

  <p id="N199F8">Regardless of which form of placeholder you use, Active Record takes great care to quote and escape the values being substituted into the SQL. Use these forms of dynamic SQL, and Active Record will keep you safe from injection attacks.</p>

  <h4 id="heading_id_5">Using Like Clauses</h4>

  <p id="N199FF">We might be tempted to do something like the code on the next page to use parameterized <code class="cf ic">like</code> clauses in conditions.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># Doesn't work</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">User.where(<em class="string">"name like '?%'"</em>, params[:name])</code></td>
    </tr>
  </table>

  <p id="N19A17">Rails doesn’t parse the SQL inside a condition and so doesn’t know that the name is being substituted into a string. As a result, it will go ahead and add extra quotes around the value of the <code class="cf ic">name</code> parameter. The correct way to do this is to construct the full parameter to the <code class="cf ic">like</code> clause and pass that parameter into the condition:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># Works</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">User.where(<em class="string">"name like ?"</em>, params[:name]+<em class="string">"%"</em>)</code></td>
    </tr>
  </table>

  <p id="N19A35">Of course, if we do this, we need to consider that characters such as percent signs, should they happen to appear in the value of the name parameter, will be treated as wildcards.</p>

  <h4 id="heading_id_6">Subsetting the Records Returned</h4>

  <p id="N19A3C">Now that we know how to specify conditions, let’s turn our attention to the various methods supported by <code class="cf class">ActiveRecord::Relation</code>, starting with <code class="cf methodname">first</code> and <code class="cf methodname">all</code>.</p>

  <p id="N19A48">As you may have guessed, <code class="cf methodname">first</code> returns the first row in the relation. It returns <code class="cf ic">nil</code> if the relation is empty. Similarly, <code class="cf methodname">all</code> returns all the rows as an array. <code class="cf class">ActiveRecord::Relation</code> also supports many of the methods of <code class="cf class">Array</code> objects, such as <code class="cf methodname">each</code> and <code class="cf methodname">map</code>. It does so by implicitly calling the <code class="cf methodname">all</code> first.</p>

  <p id="N19A63">It’s important to understand that the query is not evaluated until one of these methods is used. This enables us to modify the query in a number of ways, namely, by calling additional methods, prior to making this call. Let’s look at these methods now.</p>

  <p><strong>order</strong></p>

  <p id="N19A6A">SQL that rows will be returned in any particular order unless we explicitly add an <code class="cf ic">order by</code> clause to the query. The <code class="cf methodname">order</code> method lets us specify the criteria we’d normally add after the <code class="cf ic">order by</code> keywords. For example, the following query would return all of Dave’s orders, sorted first by payment type and then by shipping date (the latter in descending order):</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.where(name: <em class="string">'Dave'</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order(<em class="string">"pay_type, shipped_at DESC"</em>)</code></td>
    </tr>
  </table>

  <p><strong>limit</strong></p>

  <p id="N19AAF">We can limit the number of rows returned by calling the <code class="cf methodname">limit</code> method. Generally when we use the limit method, we’ll probably also want to specify the sort order to ensure consistent results. For example, the following returns the first ten matching orders:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.where(name: <em class="string">'Dave'</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order(<em class="string">"pay_type, shipped_at DESC"</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">limit(10)</code></td>
    </tr>
  </table>

  <p><strong>offset</strong></p>

  <p id="N19AD7">The <code class="cf methodname">offset</code> method goes hand in hand with the <code class="cf methodname">limit</code> method. It allows us to specify the offset of the first row in the result set that will be returned.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># The view wants to display orders grouped into pages,</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># where each page shows page_size orders at a time.</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># This method returns the orders on page page_num (starting</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># at zero).</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> Order.find_on_page(page_num, page_size)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order(:id).limit(page_size).offset(page_num*page_size)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19B0C">We can use <code class="cf ic">offset</code> in conjunction with <code class="cf ic">limit</code> to step through the results of a query <span class="emph">n</span> rows at a time.</p>

  <p><strong>select</strong></p>

  <p id="N19B1C">By default, <code class="cf class">ActiveRecord::Relation</code> fetches all the columns from the underlying database table&mdash;it issues a <code class="cf ic">select * from...</code> to the database. Override this with the <code class="cf methodname">select</code> method, which takes a string that will appear in place of the <code class="cf ic">*</code> in the <code class="cf ic">select</code> statement.</p>

  <p id="N19B4F">This method allows us to limit the values returned in cases where we need only a subset of the data in a table. For example, our table of podcasts might contain information on the title, speaker, and date and might also contain a large BLOB containing the MP3 of the talk. If you just wanted to create a list of talks, it would be inefficient to also load up the sound data for each row. The <code class="cf methodname">select</code> method lets us choose which columns to load.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">list = Talk.select(<em class="string">"title, speaker, recorded_on"</em>)</code></td>
    </tr>
  </table>

  <p><strong>joins</strong></p>

  <p id="N19B67">The <code class="cf methodname">joins</code> method lets us specify a list of additional tables to be joined to the default table. This parameter is inserted into the SQL immediately after the name of the model’s table and before any conditions specified by the first parameter. The join syntax is database-specific. The following code returns a list of all line items for the book called <span class="emph">Programming Ruby</span>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">LineItem.select(<em class="string">'li.quantity'</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">where(<em class="string">"pr.title = 'Programming Ruby 1.9'"</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">joins(<em class="string">"as li inner join products as pr on li.product_id = pr.id"</em>)</code></td>
    </tr>
  </table>

  <p><strong>readonly</strong></p>

  <p id="N19B9C">The <code class="cf methodname">readonly</code> method causes <code class="cf class">ActiveRecord::Resource</code> to return Active Record objects that cannot be stored back into the database.</p>

  <p id="N19BB3">If we use the <code class="cf methodname">joins</code> or <code class="cf methodname">select</code> methods, objects will automatically be marked <code class="cf ic">readonly</code>.</p>

  <p><strong>group</strong></p>

  <p id="N19BC3">The <code class="cf methodname">group</code> method adds a <code class="cf ic">group by</code> clause to the SQL generated by <code class="cf methodname">find</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">summary = LineItem.select(<em class="string">"sku, sum(amount) as amount"</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">group(<em class="string">"sku"</em>)</code></td>
    </tr>
  </table>

  <p><strong>lock</strong></p>

  <p id="N19C06">The <code class="cf methodname">lock</code> method takes an optional string as a parameter. If we pass it a string, it should be a SQL fragment in our database’s syntax that specifies a kind of lock. With MySQL, for example, a <span class="emph">share mode</span> lock gives us the latest data in a row and guarantees that no one else can alter that row while we hold the lock. We could write code that debits an account only if there are sufficient funds using something like the following:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Account.transaction <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ac = Account.where(id: id).lock(<em class="string">"LOCK IN SHARE MODE"</em>).first</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ac.balance -= amount <strong class="prompt">if</strong> ac.balance &gt; amount</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">ac.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19C43">If we don’t specify a string value or we give <code class="cf methodname">lock</code> a value of <code class="cf constant">true</code>, the database’s default exclusive lock is obtained (normally this will be <code class="cf ic">"for update"</code>). We can often eliminate the need for this kind of locking using transactions (discussed starting <a href="../Text/f_0107.html#sec.transactions">​here​</a>).</p>

  <p id="N19C52">Databases can do more than simply find and reliably retrieve data, they can also do a bit of data reduction analysis. Rails provides access to these methods too.</p>

  <h4 id="sec.sum">Getting Column Statistics</h4>

  <p id="N19C5A">Rails has the ability to perform statistics on the values in a column. For example, given a table of orders, we can calculate the following:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">average = Order.average(:amount) <em class="comment"># average amount of orders</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">max = Order.maximum(:amount)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">min = Order.minimum(:amount)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">total = Order.sum(:amount)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">number = Order.count</code></td>
    </tr>
  </table>

  <p id="N19CB3">These all correspond to aggregate functions in the underlying database, but they work in a database-independent manner.</p>

  <p id="N19CB6">As before, methods can be combined:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.where(<em class="string">"amount &gt; 20"</em>).minimum(:amount)</code></td>
    </tr>
  </table>

  <p id="N19CC7">These functions aggregate values. By default, they return a single result, producing, for example, the minimum order amount for orders meeting some condition. However, if you include the <code class="cf ic">group</code> method, the functions instead produce a series of results, one result for each set of records where the grouping expression has the same value. For example, the following calculates the maximum sale amount for each state:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">result = Order.maximum(:amount).group(:state)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts result <em class="comment">#=&gt; [["TX", 12345], ["NC", 3456], ...]</em></code></td>
    </tr>
  </table>

  <p id="N19CDD">This code returns an ordered hash. You index it using the grouping element (<code class="cf ic">"TX"</code>, <code class="cf ic">"NC"</code>, … in our example). You can also iterate over the entries in order using <code class="cf methodname">each</code>. The value of each entry is the value of the aggregation function.</p>

  <p id="N19CE9">The <code class="cf ic">order</code> and <code class="cf ic">limit</code> methods come into their own when using groups.</p>

  <p id="N19CF2">For example, the following returns the three states with the highest orders, sorted by the order amount:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">result = Order.group(:state).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order(<em class="string">"max(amount) desc"</em>).</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">limit(3)</code></td>
    </tr>
  </table>

  <p id="N19D09">This code is no longer database independent&mdash;in order to sort on the aggregated column, we had to use the SQLite syntax for the aggregation function (<code class="cf ic">max</code>, in this case).</p>

  <h4 id="sec.scopes">Scopes</h4>

  <p id="N19D14">As these chains of method calls grow longer, making the chains themselves available for reuse becomes a concern. Once again, Rails delivers. An Active Record <span class="emph">scope</span> can be associated with a Proc and therefore may have arguments:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Order &lt; ActiveRecord::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">scope :last_n_days, lambda { |days| where(<em class="string">'updated &lt; ?'</em> , days) }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19D40">Such a named scope would make finding the last week’s worth of orders a snap:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.last_n_days(7)</code></td>
    </tr>
  </table>

  <p id="N19D4E">Simpler scopes can simply be a set of method calls:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Order &lt; ActiveRecord::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">scope :checks, where(pay_type: :check)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19D65">Scopes can also be combined. Finding the last week’s worth of orders that were paid by check is just as easy:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.checks.last_n_days(7)</code></td>
    </tr>
  </table>

  <p id="N19D73">In addition to making your application code easier to write and easier to read, scopes can make your code more efficient. The previous statement, for example, is implemented as a single SQL query.</p>

  <p id="N19D76"><code class="cf class">ActiveRecord::Relation</code> objects are equivalent to an anonymous scope:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">in_house = Order.where(<em class="string">'email LIKE "%@pragprog.com"'</em>)</code></td>
    </tr>
  </table>

  <p id="N19D89">Of course, relations can also be combined:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">in_house.checks.last_n_days(7)</code></td>
    </tr>
  </table>

  <p id="N19D97">Scopes aren’t limited to where conditions; we can do pretty much anything we can do in a method call: <code class="cf ic">limit</code>, <code class="cf ic">order</code>, <code class="cf ic">join</code>, and so on. Just be aware that Rails doesn’t know how to handle multiple <code class="cf ic">order</code> or <code class="cf ic">limit</code> clauses, so be sure to use these only once per call chain.</p>

  <p id="N19DA9">In nearly every case, these methods that we have been describing are sufficient. But Rails is not satisfied with only being able to handle nearly every case, so for the cases that require a human-crafted query, there is an API for that too.</p>

  <h4 id="heading_id_7">Writing Our Own SQL</h4>

  <p id="N19DB0">Each of the methods we have been looking at contributes to the construction of a full SQL query string. The method <code class="cf methodname">find_by_sql</code> lets our application take full control. It accepts a single parameter containing a SQL <code class="cf ic">select</code> statement (or an array containing SQL and placeholder values, as for <code class="cf methodname">find</code>) and returns a (potentially empty) array of model objects from the result set. The attributes in these models will be set from the columns returned by the query. We’d normally use the <code class="cf ic">select&nbsp;*</code> form to return all columns for a table, but this isn’t required.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/find_examples.rb">rails31/e1/ar/find_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = LineItem.find_by_sql(<em class="string">"select line_items.* from line_items, orders "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" where order_id = orders.id "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" and orders.name = 'Dave Thomas' "</em>)</code></td>
    </tr>
  </table>

  <p id="N19DEB">Only those attributes returned by a query will be available in the resulting model objects. We can determine the attributes available in a model object using the <code class="cf methodname">attributes</code>, <code class="cf methodname">attribute_names</code>, and <code class="cf methodname">attribute_present?</code> methods. The first returns a hash of attribute name/value pairs, the second returns an array of names, and the third returns <code class="cf constant">true</code> if a named attribute is available in this model object.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/find_examples.rb">rails31/e1/ar/find_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.find_by_sql(<em class="string">"select name, pay_type from orders"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">first = orders[0]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">p first.attributes</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">p first.attribute_names</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">p first.attribute_present?(<em class="string">"address"</em>)</code></td>
    </tr>
  </table>

  <p id="N19E3B">This code produces the following:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{"name"=&gt;"Dave Thomas", "pay_type"=&gt;"check"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">["name", "pay_type"]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">false</code></td>
    </tr>
  </table>

  <p id="N19E4E"><code class="cf methodname">find_by_sql</code> can also be used to create model objects containing derived column data. If we use the <code class="cf ic">as xxx</code> SQL syntax to give derived columns a name in the result set, this name will be used as the name of the attribute.</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/e1/ar/find_examples.rb">rails31/e1/ar/find_examples.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">items = LineItem.find_by_sql(<em class="string">"select *, "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" products.price as unit_price, "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" quantity*products.price as total_price, "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" products.title as title "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" from line_items, products "</em> +</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="string">" where line_items.product_id = products.id "</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">li = items[0]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts <em class="string">"</em>#{li.title}<em class="string">:</em> #{li.quantity}<em class="string">x</em>#{li.unit_price} <em class="string">=&gt;</em> #{li.total_price}<em class="string">"</em></code></td>
    </tr>
  </table>

  <p id="N19EA8">As with conditions, we can also pass an array to <code class="cf methodname">find_by_sql</code>, where the first element is a string containing placeholders. The rest of the array can be either a hash or a list of values to be substituted.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.find_by_sql([<em class="string">"select * from orders where amount &gt; ?"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">params[:amount]])</code></td>
    </tr>
  </table>

  <div class="xxxsays">
    <div class="heading">
      <div class="persons-picture"><img alt="David says:" src="../Images/David.png" /></div>

      <div class="label">
        David says:
      </div>

      <div class="title">
        But Isn’t SQL Dirty?
      </div>
    </div>

    <div class="body">
      <p id="N19EC3">Ever since developers first wrapped relational databases with an object-oriented layer, they’ve debated the question of how deep to run the abstraction. Some object-relational mappers seek to eliminate the use of SQL entirely, hoping for object-oriented purity by forcing all queries through an OO layer.</p>

      <p id="N19EC6">Active Record does not. It was built on the notion that SQL is neither dirty nor bad, just verbose in the trivial cases. The focus is on removing the need to deal with the verbosity in those trivial cases (writing a ten-attribute <code class="cf ic">insert</code> by hand will leave any programmer tired) but keeping the expressiveness around for the hard queries&mdash;the type SQL was created to deal with elegantly.</p>

      <p id="N19ECC">Therefore, you shouldn’t feel guilty when you use <code class="cf methodname">find_by_sql</code> to handle either performance bottlenecks or hard queries. Start out using the object-oriented interface for productivity and pleasure, and then dip beneath the surface for a close-to-the-metal experience when you need to do so.</p>
    </div>
  </div>

  <p id="N19EDD">In the old days of Rails, people frequently resorted to using <code class="cf methodname">find_by_sql</code>. Since then, all the options added to the basic <code class="cf methodname">find</code> method mean that you can avoid resorting to this low-level method.</p>

  <h4 id="heading_id_8">Reloading Data</h4>

  <p id="N19EFB">In an application where the database is potentially being accessed by multiple processes (or by multiple applications), there’s always the possibility that a fetched model object has become stale&mdash;someone may have written a more recent copy to the database.</p>

  <p id="N19EFE">To some extent, this issue is addressed by transactional support (which we describe <a href="../Text/f_0107.html#sec.transactions">​here​</a>). However, there’ll still be times where you need to refresh a model object manually. Active Record makes this easy&mdash;simply call its <code class="cf methodname">reload</code> method, and the object’s attributes will be refreshed from the database:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">stock = Market.find_by_ticker(<em class="string">"RUBY"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">loop <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts <em class="string">"Price =</em> #{stock.price}<em class="string">"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">sleep 60</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">stock.reload</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N19F37">In practice, <code class="cf methodname">reload</code> is rarely used outside the context of unit tests.</p>

  <h3 id="heading_id_9">Updating Existing Rows</h3>

  <p id="N19F41">After such a long discussion of finder methods, you’ll be pleased to know that there’s not much to say about updating records with Active Record.</p>

  <p id="N19F44">If you have an Active Record object (perhaps representing a row from our <code class="cf sqltable">orders</code> table), you can write it to the database by calling its <code class="cf methodname">save</code> method. If this object had previously been read from the database, this save will update the existing row; otherwise, the save will insert a new row.</p>

  <p id="N19F65">If an existing row is updated, Active Record will use its primary key column to match it with the in-memory object. The attributes contained in the Active Record object determine the columns that will be updated&mdash;a column will be updated in the database only if its value has been changed. In the following example, all the values in the row for order 123 can be updated in the database table:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(123)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.name = <em class="string">"Fred"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.save</code></td>
    </tr>
  </table>

  <p id="N19F7B">However, in the following example, the Active Record object contains just the attributes <code class="cf sqlcolumn">id</code>, <code class="cf sqlcolumn">name</code>, and <code class="cf sqlcolumn">paytype</code>&mdash;only these columns can be updated when the object is saved. (Note that you have to include the <code class="cf sqlcolumn">id</code> column if you intend to save a row fetched using <code class="cf methodname">find_by_sql</code>.)</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">orders = Order.find_by_sql(<em class="string">"select id, name, pay_type from orders where id=123"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">first = orders[0]</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">first.name = <em class="string">"Wilma"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">first.save</code></td>
    </tr>
  </table>

  <p id="N19FA6">In addition to the <code class="cf methodname">save</code> method, Active Record lets us change the values of attributes and save a model object in a single call to <code class="cf methodname">update_attribute</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(123)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.update_attribute(:name, <em class="string">"Barney"</em>)</code></td>
    </tr>
  </table>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(321)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.update_attributes(name: <em class="string">"Barney"</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">email: <em class="string">"barney@bedrock.com"</em>)</code></td>
    </tr>
  </table>

  <p id="N19FE2">The <code class="cf methodname">update_attributes</code> method is most commonly used in controller actions where it merges data from a form into an existing database row:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> save_after_edit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find(params[:id])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> order.update_attributes(params[:order])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">redirect_to action: :index</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">else</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">render action: :edit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1A01D">We can combine the functions of reading a row and updating it using the class methods <code class="cf methodname">update</code> and <code class="cf methodname">update_all</code>. The <code class="cf methodname">update</code> method takes an <code class="cf ic">id</code> parameter and a set of attributes. It fetches the corresponding row, updates the given attributes, saves the result to the database, and returns the model object.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.update(12, name: <em class="string">"Barney"</em>, email: <em class="string">"barney@bedrock.com"</em>)</code></td>
    </tr>
  </table>

  <p id="N1A053">We can pass <code class="cf methodname">update</code> an array of ids and an array of attribute value hashes, and it will update all the corresponding rows in the database, returning an array of model objects.</p>

  <p id="N1A059">Finally, the <code class="cf methodname">update_all</code> class method allows us to specify the <code class="cf ic">set</code> and <code class="cf ic">where</code> clauses of the SQL <code class="cf ic">update</code> statement. For example, the following increases the prices of all products with <span class="emph">Java</span> in their title by 10 percent:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">result = Product.update_all(<em class="string">"price = 1.1*price"</em>, <em class="string">"title like '%Java%'"</em>)</code></td>
    </tr>
  </table>

  <p id="N1A07C">The return value of <code class="cf methodname">update_all</code> depends on the database adapter; most (but not Oracle) return the number of rows that were changed in the database.</p>

  <h4 id="heading_id_10">save, save!, create, and create!</h4>

  <p id="N1A091">It turns out that there are two versions of the <code class="cf ic">save</code> and <code class="cf ic">create</code> methods. The variants differ in the way they report errors:</p>

  <ul>
    <li>
      <p id="N1A0C9"><code class="cf ic">save</code> returns <code class="cf ic">true</code> if the record was saved; it returns <code class="cf ic">nil</code> otherwise.</p>
    </li>

    <li>
      <p id="N1A0D5"><code class="cf ic">save!</code> returns <code class="cf ic">true</code> if the save was successful; it raises an exception otherwise.</p>
    </li>

    <li>
      <p id="N1A0DE"><code class="cf ic">create</code> returns the Active Record object regardless of whether it was successfully saved. You’ll need to check the object for validation errors if you want to determine whether the data was written.</p>
    </li>

    <li>
      <p id="N1A0E4"><code class="cf ic">create!</code> returns the Active Record object on success; it raises an exception otherwise.</p>
    </li>
  </ul>

  <p id="N1A0E9">Let’s look at this in a bit more detail.</p>

  <p id="N1A0EC">Plain old <code class="cf methodname">save</code> returns <code class="cf constant">true</code> if the model object is valid and can be saved:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> order.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># all OK</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">else</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># validation failed</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1A11F">It’s up to us to check on each call to <code class="cf methodname">save</code> to see that it did what we expected. The reason Active Record is so lenient is that it assumes <code class="cf methodname">save</code> is called in the context of a controller’s action method and that the view code will be presenting any errors back to the end user. And for many applications, that’s the case.</p>

  <p id="N1A128">However, if we need to save a model object in a context where we want to make sure to handle all errors programmatically, we should use <code class="cf methodname">save!</code>. This method raises a <code class="cf class">RecordInvalid</code> exception if the object could not be saved:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">begin</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.save!</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">rescue</strong> RecordInvalid =&gt; error</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># validation failed</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <h3 id="heading_id_11">Deleting Rows</h3>

  <p id="N1A15D">Active Record supports two styles of row deletion. First, it has two class-level methods, <code class="cf methodname">delete</code> and <code class="cf methodname">delete_all</code>, that operate at the database level. The <code class="cf methodname">delete</code> method takes a single id or an array of ids and deletes the corresponding row(s) in the underlying table. <code class="cf methodname">delete_all</code> deletes rows matching a given condition (or all rows if no condition is specified). The return values from both calls depend on the adapter but are typically the number of rows affected. An exception is not thrown if the row doesn’t exist prior to the call.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.delete(123)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">User.delete([2,3,4,5])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Product.delete_all([<em class="string">"price &gt; ?"</em>, @expensive_price])</code></td>
    </tr>
  </table>

  <p id="N1A1A1">The various <code class="cf ic">destroy</code> methods are the second form of row deletion provided by Active Record. These methods all work via Active Record model objects.</p>

  <p id="N1A1A7">The <code class="cf methodname">destroy</code> instance method deletes from the database the row corresponding to a particular model object. It then freezes the contents of that object, preventing future changes to the attributes.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order = Order.find_by_name(<em class="string">"Dave"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">order.destroy</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># ... order is now frozen</em></code></td>
    </tr>
  </table>

  <p id="N1A1CD">There are two class-level destruction methods, <code class="cf methodname">destroy</code> (which takes an id or an array of ids) and <code class="cf methodname">destroy_all</code> (which takes a condition). Both read the corresponding rows in the database table into model objects and call the instance-level <code class="cf methodname">destroy</code> method of those objects. Neither method returns anything meaningful.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Order.destroy_all([<em class="string">"shipped_at &lt; ?"</em>, 30.days.ago])</code></td>
    </tr>
  </table>

  <p id="N1A1F2">Why do we need both the <code class="cf ic">delete</code> and <code class="cf ic">destroy</code> class methods? The <code class="cf ic">delete</code> methods bypass the various Active Record callback and validation functions, while the <code class="cf ic">destroy</code> methods ensure that they are all invoked. In general, it is better to use the <code class="cf ic">destroy</code> methods if you want to ensure that your database is consistent according to the business rules defined in your model classes.</p>

  <p id="N1A204">We covered validation in Chapter 7, <a href="../Text/f_0046.html#chp.Validation">​<em>Task B: Validation and Unit Testing</em>​</a>. We cover callbacks next.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
