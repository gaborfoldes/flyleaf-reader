<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.templates">21.1 Using Templates</h2>

  <p id="N1C255">When you write a view, you’re writing a template: something that will get expanded to generate the final result. To understand how these templates work, we need to look at three areas:</p>

  <ul>
    <li>
      <p id="N1C25B">Where the templates go</p>
    </li>

    <li>
      <p id="N1C25F">The environment they run in</p>
    </li>

    <li>
      <p id="N1C263">What goes inside them</p>
    </li>
  </ul>

  <h3 id="heading_id_2">Where Templates Go</h3>

  <p id="N1C26A">The <code class="cf methodname">render</code> method expects to find templates in the <code class="cf dir">app/views</code> directory of the current application. Within this directory, the convention is to have a separate subdirectory for the views of each controller. Our Depot application, for instance, includes products and store controllers. As a result, we have templates in <code class="cf dir">app/views/products</code> and <code class="cf dir">app/views/store</code>. Each directory typically contains templates named after the actions in the corresponding controller.</p>

  <p id="N1C28F">You can also have templates that aren’t named after actions. You render such templates from the controller using calls such as these:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">render(action: <em class="string">'fake_action_name'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">render(template: <em class="string">'controller/name'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">render(file: <em class="string">'dir/template'</em>)</code></td>
    </tr>
  </table>

  <p id="N1C2AC">The last of these allows you to store templates anywhere on your filesystem. This is useful if you want to share templates across applications.</p>

  <h3 id="heading_id_3">The Template Environment</h3>

  <p id="N1C2B3">Templates contain a mixture of fixed text and code. The code in the template adds dynamic content to the response. That code runs in an environment that gives it access to the information set up by the controller.</p>

  <ul>
    <li>
      <p id="N1C2BF">All instance variables of the controller are also available in the template. This is how actions communicate data to the templates.</p>
    </li>

    <li>
      <p id="N1C2C3">The controller object’s <code class="cf variable">flash</code>, <code class="cf variable">headers</code>, <code class="cf variable">logger</code>, <code class="cf variable">params</code>, <code class="cf variable">request</code>, <code class="cf variable">response</code>, and <code class="cf variable">session</code> are available as accessor methods in the view. Apart from the flash, view code probably should not use these directly, because the responsibility for handling them should rest with the controller. However, we do find this useful when debugging. For example, the following <code class="cf ic">html.erb</code> template uses the <code class="cf methodname">debug</code> method to display the contents of the session, the details of the parameters, and the current response:</p>

      <table class="processedcode">
        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h4&gt;</strong>Session<strong class="prompt">&lt;/h4&gt;</strong> <em class="comment">&lt;%= debug(session) %&gt;</em></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h4&gt;</strong>Params<strong class="prompt">&lt;/h4&gt;</strong> <em class="comment">&lt;%= debug(params) %&gt;</em></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h4&gt;</strong>Response<strong class="prompt">&lt;/h4&gt;</strong> <em class="comment">&lt;%= debug(response) %&gt;</em></code></td>
        </tr>
      </table>
    </li>

    <li>
      <p id="N1C3AD">The current controller object is accessible using the attribute named <code class="cf variable">controller</code>. This allows the template to call any public method in the controller (including the methods in <code class="cf class">ActionController::Base</code>).</p>
    </li>

    <li>
      <p id="N1C3CD">The path to the base directory of the templates is stored in the attribute <code class="cf variable">base_path</code>.</p>
    </li>
  </ul>

  <h3 id="heading_id_4">What Goes in a Template</h3>

  <p id="N1C3EC">Out of the box, Rails supports four types of templates:</p>

  <table class="figure" id="fig.html.forms">
    <tr>
      <td><img alt="images/form_helpers.png" src="../Images/form_helpers.png" xmlns:str="http://exslt.org/strings" /></td>
    </tr>

    <tr>
      <td align="center">
        <hr />
        <b>Figure 48. Some of the common ways to enter data into forms</b>
      </td>
    </tr>
  </table>

  <ul>
    <li>
      <p id="N1C3FB">Builder templates use the Builder library to construct XML responses. We talk more about Builder in Section 25.1, <a href="../Text/f_0136.html#sec.builder">​<em>Generating XML with Builder</em>​</a>.</p>
    </li>

    <li>
      <p id="N1C402">CoffeeScript templates create JavaScript, which can change both the presentation and the behavior of your content in the browser.</p>
    </li>

    <li>
      <p id="N1C406">ERb templates are a mixture of content and embedded Ruby. They are typically used to generate HTML pages. We talk more about ERB in Section 25.2, <a href="../Text/f_0137.html#sec.rhtml">​<em>Generating HTML with ERb</em>​</a>.</p>
    </li>

    <li>
      <p id="N1C40D">SCSS templates create CSS stylesheets to control the presentation of your content in the browser.</p>
    </li>
  </ul>

  <p id="N1C410">By far, the one that you will be using the most will be ERB. In fact, you made extensive use of ERB templates in developing the Depot application.</p>

  <p id="N1C414">So far in this chapter, we have focused on producing output. In Chapter 20, <a href="../Text/f_0108.html#chp.actioncontroller">​<em>Action Dispatch and Action Controller</em>​</a>, we focused on processing input. In a well-designed application, these two are not unrelated: the output we produce contains forms, links, and buttons that guide the end user to producing the next set of inputs. As you might expect by now, Rails provides considerable amount of help in this area too.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
