<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="heading_id_2">4.4 Organizing Structures</h2>

  <p id="N1170F">There are two basic concepts in Ruby for organizing methods, namely, classes and modules. We cover each in turn.</p>

  <h3 id="wtf.class.def">Classes</h3>

  <p id="N11717">Here’s a Ruby class definition:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix"><span class="codeprefix">Line 1</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Order &lt; ActiveRecord::Base</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1">has_many :line_items</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> self.find_all_unpaid</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">5</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1">self.where(<em class="string">'paid = 0'</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> total</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1">sum = 0</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">10</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1">line_items.each {|li| sum += li.total}</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1">sum</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codeprefix">-</span>&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N11773">Class definitions start with the keyword <code class="cf ic">class</code> followed by the class name (which must start with an uppercase letter). This <code class="cf class">Order</code> class is defined to be a subclass of the class <code class="cf class">Base</code> within the <code class="cf class">ActiveRecord</code> module.</p>

  <p id="N11782">Rails makes heavy use of class-level declarations. Here <code class="cf ic">has_many</code> is a method that’s defined by Active Record. It’s called as the <code class="cf class">Order</code> class is being defined. Normally these kinds of methods make assertions about the class, so in this book we call them <span class="firstuseinline">declarations</span>.</p>

  <p id="wtf.self.def">Within a class body you can define class methods and instance methods. Prefixing a method name with <code class="cf ic">self.</code>(as we do on line 4) makes it a class method; it can be called on the class generally. In this case, we can make the following call anywhere in our application:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">to_collect = Order.find_all_unpaid</code></td>
    </tr>
  </table>

  <p id="wtf.instance.variable">Objects of a class hold their state in <span class="firstuseinline">instance variables</span>. These variables, whose names all start with <code class="cf ic">@</code>, are available to all the instance methods of a class. Each object gets its own set of instance variables.</p>

  <p id="wtf.attr.accessor">Instance variables are not directly accessible outside the class. To make them available, write methods that return their values:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Greeter</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> initialize(name)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@name = name</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> name</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@name</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> name=(new_name)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@name = new_name</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">g = Greeter.new(<em class="string">"Barney"</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts g.name <em class="comment">#=&gt; Barney</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">g.name = <em class="string">"Betty"</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">puts g.name <em class="comment">#=&gt; Betty</em></code></td>
    </tr>
  </table>

  <p id="N11834">Ruby provides convenience methods that write these accessor methods for you (which is great news for folks tired of writing all those getters and setters):</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> Greeter</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">attr_accessor :name <em class="comment"># create reader and writer methods</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">attr_reader :greeting <em class="comment"># create reader only</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">attr_writer :age <em class="comment"># create writer only</em></code></td>
    </tr>
  </table>

  <p id="N11859">A class’s instance methods are public by default; anyone can call them. You’ll probably want to override this for methods that are intended to be used only by other class instance methods:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> MyClass</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> m1 <em class="comment"># this method is public</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">protected</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> m2 <em class="comment"># this method is protected</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">private</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> m3 <em class="comment"># this method is private</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="wtf.private">The <code class="cf ic">private</code> directive is the strictest; private methods can be called only from within the same instance. Protected methods can be called both in the same instance and by other instances of the same class and its subclasses.</p>

  <p id="N118E2">Classes are not the only organizing structure in Ruby. The other organizing structure is a module.</p>

  <h3 id="wtf.module">Modules</h3>

  <p id="N118EA">Modules are similar to classes in that they hold a collection of methods, constants, and other module and class definitions. Unlike classes, you cannot create objects based on modules.</p>

  <p id="N118ED">Modules serve two purposes. First, they act as a namespace, letting you define methods whose names will not clash with those defined elsewhere. Second, they allow you to share functionality between classes&mdash;if a class <span class="firstuseinline">mixes in</span> a module, that module’s instance methods become available as if they had been defined in the class. Multiple classes can mix in the same module, sharing the module’s functionality without using inheritance. You can also mix multiple modules into a single class.</p>

  <p id="N118F3">Helper methods are an example of where Rails uses modules. Rails automatically mixes these helper modules into the appropriate view templates. For example, if you wanted to write a helper method that would be callable from views invoked by the store controller, you could define the following module in the file <code class="cf filename">store_helper.rb</code> in the <code class="cf dir">app/helpers</code> directory:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">module</strong> StoreHelper</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> capitalize_words(string)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">string.split(<em class="string">' '</em>).map {|word| word.capitalize}.join(<em class="string">' '</em>)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N11935">There is one module that is part of the standard library of Ruby that deserves special mention given its usage in Rails, namely, YAML.</p>

  <h3 id="wtf.yaml">YAML</h3>

  <p id="N1193D">YAML<a href="../Text/f_0037.html#FOOTNOTE-16" id="FNPTR-16">[16]</a> is a recursive acronym that stands for YAML Ain’t Markup Language. In the context of Rails, YAML is used as a convenient way to define configuration of things such as databases, test data, and translations. Here is an example:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">development:</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">adapter: sqlite3</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">database: db/development.sqlite3</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">pool: 5</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">timeout: 5000</code></td>
    </tr>
  </table>

  <p id="N11962">In YAML, indentation is important, so this defines <code class="cf ic">development</code> as having a set of four key/value pairs, separated by colons.</p>

  <p id="N11968">While YAML is one way to represent data, particularly when interacting with humans, Ruby provides a more general way for representing data for use by applications.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
