<?xml version="1.0" encoding="utf-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Agile Web Development with Rails</title>
  <link href="../Styles/bookshelf.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/book_local.css" rel="stylesheet" type="text/css" />
  <link href="../Styles/page-template.xpgt" rel="stylesheet" type="application/vnd.adobe-page-template+xml" />
  <meta content="rails4" name="bookcode" />
  <style type="text/css">
/*<![CDATA[*/

  code.sgc-1 {white-space: pre-wrap;}
  /*]]>*/
  </style>
</head>

<body>
  <h2 id="sec.routing">20.1 Dispatching Requests to Controllers</h2>

  <p id="N1AA25">At its simplest, a web application accepts an incoming request from a browser, processes it, and sends a response.</p>

  <p id="N1AA33">The first question that springs to mind is, how does the application know what to do with the incoming request? A shopping cart application will receive requests to display a catalog, add items to a cart, create an order, and so on. How does it route these requests to the appropriate code?</p>

  <p id="N1AA36">It turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can.</p>

  <p id="N1AA39">The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements, and conditions. The convenient way lets you define routes based on resources, such as the models that you define. And because the convenient way is built on the comprehensive way, you can freely mix and match the two approaches.</p>

  <p id="N1AA3C">In both cases, Rails encodes information in the request URL and uses a subsystem called <span class="emph">Action Dispatch</span> to determine what should be done with that request. The actual process is very flexible, but at the end of it Rails has determined the name of the <span class="firstuseinline">controller</span> that handles this particular request, along with a list of any other request parameters. In the process, either one of these additional parameters or the HTTP method itself is used to identify the <span class="firstuseinline">action</span> to be invoked in the target controller.</p>

  <p id="N1AA48">Rails routes support the mapping between URLs and actions based on the contents of the URL and on the HTTP method used to invoke the request. We’ve seen how to do this on a URL-by-URL basis using anonymous or named routes. Rails also supports a higher-level way of creating groups of related routes. To understand the motivation for this, we need to take a little diversion into the world of Representational State Transfer.</p>

  <h3 id="heading_id_2">REST: Representational State Transfer</h3>

  <p id="N1AA51">The ideas behind REST were formalized in Chapter 5 of Roy Fielding’s 2000 PhD dissertation.<a href="../Text/f_0111.html#FOOTNOTE-42" id="FNPTR-42">[42]</a> In a REST approach, servers communicate with clients using stateless connections. All the information about the state of the interaction between the two is encoded into the requests and responses between them. Long-term state is kept on the server as a set of identifiable <span class="emph">resources</span>. Clients access these resources using a well-defined (and severely constrained) set of resource identifiers (URLs in our context). REST distinguishes the content of resources from the presentation of that content. REST is designed to support highly scalable computing while constraining application architectures to be decoupled by nature.</p>

  <p id="N1AA67">There’s a lot of abstract stuff in this description. What does REST mean in practice?</p>

  <p id="N1AA6A">First, the formalities of a RESTful approach mean that network designers know when and where they can cache responses to requests. This enables load to be pushed out through the network, increasing performance and resilience while reducing latency.</p>

  <p id="N1AA6D">Second, the constraints imposed by REST can lead to easier-to-write (and maintain) applications. RESTful applications don’t worry about implementing remotely accessible services. Instead, they provide a regular (and simple) interface to a set of resources. Your application implements a way of listing, creating, editing, and deleting each resource, and your clients do the rest.</p>

  <p id="N1AA70">Let’s make this more concrete. In REST, we use a simple set of verbs to operate on a rich set of nouns. If we’re using HTTP, the verbs correspond to HTTP methods (GET, PUT, POST, and DELETE, typically). The nouns are the resources in our application. We name those resources using URLs.</p>

  <p id="N1AA79">The Depot application that we produced contained a set of products. There are implicitly two resources here. First, there are the individual products. Each constitutes a resource. There’s also a second resource: the collection of products.</p>

  <p id="N1AA82">To fetch a list of all the products, we could issue an HTTP GET request against this collection, say on the path <code class="cf ic">/products</code>. To fetch the contents of an individual resource, we have to identify it. The Rails way would be to give its primary key value (that is, its id). Again we’d issue a GET request, this time against the URL <code class="cf ic">/products/1</code>.</p>

  <p id="N1AA8B">To create a new product in our collection we use an HTTP POST request directed at the <code class="cf ic">/products</code> path, with the post data containing the product to add. Yes, that’s the same path we used to get a list of products. If you issue a GET to it, it responds with a list, and if you do a POST to it, it adds a new product to the collection.</p>

  <p id="N1AA91">Take this a step further. We’ve already seen you can retrieve the content of a product&mdash;you just issue a GET request against the path <code class="cf ic">/products/1</code>. To update that product, you’d issue an HTTP PUT request against the same URL. And, to delete it, you could issue an HTTP DELETE request, again using the same URL.</p>

  <p id="N1AA97">Take this further. Maybe our system also tracks users. Again, we have a set of resources to deal with. REST tells us to use the same set of verbs (GET, POST, PUT, and DELETE) against a similar-looking set of URLs (<code class="cf ic">/users</code>, <code class="cf ic">/users/1</code>, …).</p>

  <p id="N1AAA0">Now we see some of the power of the constraints imposed by REST. We’re already familiar with the way Rails constrains us to structure our applications a certain way. Now the REST philosophy tells us to structure the interface to our applications too. Suddenly our world gets a lot simpler.</p>

  <p id="N1AAA3">Rails has direct support for this type of interface; it adds a kind of macro route facility, called <span class="emph">resources</span>. Let’s take a look at how the <code class="cf filename">config/routes.rb</code> might have looked back in <a href="../Text/f_0044.html#sect.create.application">​<em>Creating a Rails Application</em>​</a>.</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Depot::Application.routes.draw <strong class="prompt">do</strong> |map|</code></td>
    </tr>

    <tr>
      <td class="codeprefix"><span class="codehighlightline">*</span> &nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :products</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AAD1">The <code class="cf ic">resources</code> line caused seven new routes to be added to our application. Along the way, it assumed that the application will have a controller named <code class="cf class">ProductsController</code>, containing seven actions with given names.</p>

  <p id="N1AAE6">You can take a look at the routes that were generated for us. We do this by making use of the handy <code class="cf commandname">rake routes</code> command:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">products GET /products(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"index", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">POST /products(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"create", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">new_product GET /products/new(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"new", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">edit_product GET /products/:id/edit(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"edit", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">product GET /products/:id(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"show", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">PUT /products/:id(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"update", :controller=&gt;"products"}</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">DELETE /products/:id(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"destroy", :controller=&gt;"products"}</code></td>
    </tr>
  </table>

  <p id="N1AB29">All the routes defined are spelled out in a columnar format. The lines will generally wrap on your screen; in fact, they had to be broken into two lines per route to fit on this page. The columns are (optional) route name, HTTP method, route path, and (on a separate line on this page) route requirements.</p>

  <p id="N1AB2C">Fields in parentheses are optional parts of the path. Field names preceded by a colon name variables into which this part of the path is placed for later processing by the controller.</p>

  <p id="N1AB2F">Now let’s look at the seven controller actions that these routes reference. Although we created our routes to manage the products in our application, let’s broaden this out in these descriptions and talk about resources&mdash;after all, the same seven methods will be required for all resource-based routes:</p>

  <dl>
    <dt class="force-newline"><code class="cf ic">index</code></dt>

    <dd>
      <p id="N1AB40">Returns a list of the resources.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">create</code></dt>

    <dd>
      <p id="N1AB49">Creates a new resource from the data in the POST request, adding it to the collection.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">new</code></dt>

    <dd>
      <p id="N1AB52">Constructs a new resource and passes it to the client. This resource will not have been saved on the server. You can think of the <code class="cf ic">new</code> action as creating an empty form for the client to fill in.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">show</code></dt>

    <dd>
      <p id="N1AB5E">Returns the contents of the resource identified by <code class="cf ic">params[:id]</code>.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">update</code></dt>

    <dd>
      <p id="N1AB6A">Updates the contents of the resource identified by <code class="cf ic">params[:id]</code> with the data associated with the request.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">edit</code></dt>

    <dd>
      <p id="N1AB76">Returns the contents of the resource identified by <code class="cf ic">params[:id]</code> in a form suitable for editing.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">destroy</code></dt>

    <dd>
      <p id="N1AB82">Destroys the resource identified by <code class="cf ic">params[:id]</code>.</p>
    </dd>
  </dl>

  <p id="N1AB88">You can see that these seven actions contain the four basic CRUD operations (create, read, update, and delete). They also contain an action to list resources and two auxiliary actions that return new and existing resources in a form suitable for editing on the client.</p>

  <p id="N1AB8B">If for some reason you don’t need or want all seven actions, you can limit the actions produced using <code class="cf ic">:only</code> or <code class="cf ic">:except</code> options on your <code class="cf ic">resources</code>:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :comments, :except =&gt; [:update, :destroy]</code></td>
    </tr>
  </table>

  <p id="N1ABA2">Several of the routes are named routes enabling you to use helper functions such as <code class="cf ic">products_url</code> and <code class="cf ic">edit_product_url(:id=&gt;1)</code>.</p>

  <p id="N1ABB0">Note that each route is defined with an optional format specifier. We will cover formats in more detail in <a href="#sec.route.format">​<em>Selecting a Data Representation</em>​</a>.</p>

  <p id="N1ABB6">Let’s take a look at the controller code:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_a/app/controllers/products_controller.rb">rails31/depot_a/app/controllers/products_controller.rb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">class</strong> ProductsController &lt; ApplicationController</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> index</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@products = Product.all</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html <em class="comment"># index.html.erb</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @products }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products/1</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products/1.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> show</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.find(params[:id])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html <em class="comment"># show.html.erb</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @product }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products/new</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products/new.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> new</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.new</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html <em class="comment"># new.html.erb</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @product }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># GET /products/1/edit</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> edit</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.find(params[:id])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># POST /products</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># POST /products.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> create</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.new(params[:product])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> @product.save</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html { redirect_to @product,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">notice: <em class="string">'Product was successfully created.'</em> }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @product, status: :created,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">location: @product }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">else</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html { render action: <em class="string">"new"</em> }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @product.errors,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">status: :unprocessable_entity }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># PUT /products/1</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># PUT /products/1.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> update</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.find(params[:id])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">if</strong> @product.update_attributes(params[:product])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html { redirect_to @product,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">notice: <em class="string">'Product was successfully updated.'</em> }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { head :ok }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">else</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html { render action: <em class="string">"edit"</em> }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { render json: @product.errors,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">status: :unprocessable_entity }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># DELETE /products/1</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><em class="comment"># DELETE /products/1.json</em></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> destroy</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product = Product.find(params[:id])</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">@product.destroy</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html { redirect_to products_url }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.json { head :ok }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AD3C">Notice how we have one action for each of the RESTful actions. The comment before each shows the format of the URL that invokes it.</p>

  <p id="N1AD3F">Notice also that many of the actions contain a <code class="cf methodname">respond_to</code> block. As we saw <a href="../Text/f_0065.html#chp.ajax.cart">​here​</a>, Rails uses this to determine the type of content to send in a response. The scaffold generator automatically creates code that will respond appropriately to requests for HTML or XML content. We’ll play with that in a little while.</p>

  <p id="N1AD53">The views created by the generator are fairly straightforward. The only tricky thing is the need to use the correct HTTP method to send requests to the server. For example, the view for the <code class="cf ic">index</code> action looks like this:</p>

  <table class="processedcode">
    <tr class="livecodelozenge">
      <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_a/app/views/products/index.html.erb">rails31/depot_a/app/views/products/index.html.erb</a></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;h1&gt;</strong>Listing products<strong class="prompt">&lt;/h1&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;table&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;tr&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong>Title<strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong>Description<strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong>Image url<strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong>Price<strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong> <strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong> <strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;th&gt;</strong> <strong class="prompt">&lt;/th&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/tr&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% @products.each <strong class="prompt">do</strong> |product| %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;tr&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= product.title %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= product.description %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= product.image_url %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= product.price %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= link_to <em class="string">'Show'</em>, product %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= link_to <em class="string">'Edit'</em>, edit_product_path(product) %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;td&gt;</strong>&lt;%= link_to <em class="string">'Destroy'</em>, product, confirm: <em class="string">'Are you sure?'</em>,</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">method: :delete %&gt;<strong class="prompt">&lt;/td&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/tr&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;% <strong class="prompt">end</strong> %&gt;</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;/table&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">&lt;br</strong> <strong class="prompt">/&gt;</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">&lt;%= link_to <em class="string">'New Product'</em>, new_product_path %&gt;</code></td>
    </tr>
  </table>

  <p id="N1AE35">The links to the actions that edit a product and add a new product should both use regular GET methods, so a standard <code class="cf ic">link_to</code> works fine. However, the request to destroy a product must issue an HTTP DELETE, so the call includes the <code class="cf ic">:method =&gt; :delete</code> option to <code class="cf ic">link_to</code>.</p>

  <h3 id="sec.collections.and.members">Adding Additional Actions</h3>

  <p id="N1AE63">Rails resources provide you with an initial set of actions, but you don’t need to stop there. In Section 12.2, <a href="../Text/f_0074.html#sect.atom.feeds">​<em>Iteration G2: Atom Feeds</em>​</a>, we added an interface to allow people to fetch a list of people who bought any given product. To do that with Rails, we use an extension to the <code class="cf ic">resources</code> call:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">Depot::Application.routes.draw <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :products <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">get :who_bought, on: :member</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AEA1">That syntax is straightforward. It says “We want to add a new action named <code class="cf ic">who_bought</code>, invoked via an HTTP GET. It applies to each member of the collection of products.”</p>

  <p id="N1AEA7">Instead of specifying <code class="cf ic">:member</code>, if we instead specified <code class="cf ic">:collection</code>, then the route would apply to the collection as a whole. This is often used for scoping; for example, you may have collections of products on clearance or products that have been discontinued.</p>

  <h3 id="heading_id_3">Nested Resources</h3>

  <p id="N1AEB4">Often our resources themselves contain additional collections of resources. For example, we may want to allow folks to review our products. Each review would be a resource, and collections of review would be associated with each product resource.</p>

  <p id="N1AEB7">Rails provides a convenient and intuitive way of declaring the routes for this type of situation:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :products <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :reviews</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AED9">This defines the top-level set of products routes and additionally creates a set of subroutes for reviews. Because the review resources appear inside the products block, a review resource <span class="emph">must</span> be qualified by a product resource. This means that the path to a review must always be prefixed by the path to a particular product. To fetch the review with id 4 for the product with an id of 99, you’d use a path of <code class="cf ic">/products/99/reviews/4</code>.</p>

  <p id="N1AEE2">The named route for <code class="cf ic">/products/:product_id/reviews/:id</code> is <code class="cf ic">product_</code> <code class="cf ic">review</code>, not simply <code class="cf ic">review</code>. This naming simply reflects the nesting of these resources.</p>

  <p id="N1AEF0">As always, you can see the full set of routes generated by our configuration by using the <code class="cf commandname">rake routes</code> command.</p>

  <h3 id="heading_id_4">Shallow Route Nesting</h3>

  <p id="N1AEFA">At times, nested resources can produce cumbersome URLs. A solution to this is to use shallow route nesting:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :products, shallow: true <strong class="prompt">do</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">resources :reviews</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AF11">This will enable the recognition of the following routes:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">/products/1 =&gt; product_path(1)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">/products/1/reviews =&gt; product_reviews_index_path(1)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">/reviews/2 =&gt; reviews_path(2)</code></td>
    </tr>
  </table>

  <p id="N1AF24">Try the <code class="cf ic">rake routes</code> command to see the full mapping.</p>

  <h3 id="sec.route.format">Selecting a Data Representation</h3>

  <p id="N1AF2F">One of the goals of a REST architecture is to decouple data from its representation. If a human uses the URL path <code class="cf ic">/products</code> to fetch some products, they should see nicely formatted HTML. If an application asks for the same URL, it could elect to receive the results in a code-friendly format (YAML, JSON, or XML, perhaps).</p>

  <p id="N1AF35">We’ve already seen how Rails can use the HTTP Accept header in a <code class="cf ic">respond_to</code> block in the controller. However, it isn’t always easy (and sometimes it’s plain impossible) to set the Accept header. To deal with this, Rails allows you to pass the format of response you’d like as part of the URL. To do this, set a <code class="cf ic">:format</code> parameter in your routes to the file extension of the MIME type you’d like returned. As you have seen, Rails accomplishes this by including a field called <code class="cf ic">:format</code> in your route definitions:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">GET /products(.:format)</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">{:action=&gt;"index", :controller=&gt;"products"}</code></td>
    </tr>
  </table>

  <p id="N1AF8C">Because a full stop (period) is a separator character in route definitions, <code class="cf ic">:format</code> is treated as just another field. Because we give it a <code class="cf ic">nil</code> default value, it’s an optional field.</p>

  <p id="N1AF95">Having done this, we can use a <code class="cf methodname">respond_to</code> block in our controllers to select our response type depending on the requested format:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> show</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">respond_to <strong class="prompt">do</strong> |format|</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.html</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.xml { render xml: @product.to_xml }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">format.yaml { render text: @product.to_yaml }</code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>

    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
    </tr>
  </table>

  <p id="N1AFCB">Given this, a request to <code class="cf ic">/store/show/1</code> or <code class="cf ic">/store/show/1.html</code> will return HTML content, while <code class="cf ic">/store/show/1.xml</code> will return XML and <code class="cf ic">/store/show/1.yaml</code> will return YAML. You can also pass the format in as an HTTP request parameter:</p>

  <table class="processedcode">
    <tr>
      <td class="codeprefix">&nbsp;</td>

      <td class="codeline"><code class="sgc-1">GET HTTP://pragprog.com/store/show/123?format=xml</code></td>
    </tr>
  </table>

  <p id="N1AFEF">The routes defined by <code class="cf ic">resources</code> have this facility enabled by default.</p>

  <p id="N1AFF5">Although the idea of having a single controller that responds with different content types seems appealing, the reality is tricky. In particular, it turns out that error handling can be tough. Although it’s acceptable on error to redirect a user to a form, showing them a nice flash message, you have to adopt a different strategy when you serve XML. Consider your application architecture carefully before deciding to bundle all your processing into single controllers.</p>

  <p id="N1AFF8">Rails makes it simple to develop an application that is based on resource-based routing. Many claim it greatly simplifies the coding of their applications. However, it isn’t always appropriate. Don’t feel compelled to use it if you can’t find a way of making it work. And you can always mix and match. Some controllers can be resource based, and others can be based on actions. Some controllers can even be resource based with a few extra actions.</p>

  <h3 id="sec.test.routing">Testing Routes</h3>

  <p id="N1B00B">So far we’ve been exploring routes by viewing them using <code class="cf ic">rake routes</code>. When it comes time to roll out an application, though, we might want to be a little more formal and include unit tests that verify our routes work as expected. Rails includes a number of test helpers that make this easy:</p>

  <dl>
    <dt class="force-newline"><code class="cf ic">assert_generates(path, options, defaults={}, extras={}, message=nil)</code></dt>

    <dd>
      <p id="N1B024">Verifies that the given set of options generates the specified path.</p>

      <table class="processedcode">
        <tr class="livecodelozenge">
          <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_t/test/unit/routing_test.rb">rails31/depot_t/test/unit/routing_test.rb</a></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> test_generates</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_generates(<em class="string">"/"</em>, controller: <em class="string">"store"</em>, action: <em class="string">"index"</em>)</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_generates(<em class="string">"/products"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{ controller: <em class="string">"products"</em>, action: <em class="string">"index"</em>})</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_generates(<em class="string">"/line_items"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{ controller: <em class="string">"line_items"</em>, action: <em class="string">"create"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">product_id: <em class="string">"1"</em>},</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{method: :post}, { product_id: <em class="string">"1"</em>})</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
        </tr>
      </table>

      <p id="N1B07A">The <code class="cf ic">extras</code> parameter is used to tell the request the names and values of additional request parameters (in the third assertion in the previous code, this would be <code class="cf ic">product_id=1</code>). The test framework does not add these as strings to the generated URL; instead, it tests that the values it would have added appears in the <code class="cf ic">extras</code> hash.</p>

      <p id="N1B086">The <code class="cf ic">defaults</code> parameter can be used to specify the HTTP method.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">assert_recognizes(options, path, extras={}, message=nil)</code></dt>

    <dd>
      <p id="N1B092">Verifies that routing returns a specific set of options given a path.</p>

      <table class="processedcode">
        <tr class="livecodelozenge">
          <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_t/test/unit/routing_test.rb">rails31/depot_t/test/unit/routing_test.rb</a></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> test_recognizes</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="comment"># Check the default index action gets generated</em></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_recognizes({<em class="string">"controller"</em> =&gt; <em class="string">"store"</em>, <em class="string">"action"</em> =&gt; <em class="string">"index"</em>}, <em class="string">"/"</em>)</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="comment"># Check routing to an action</em></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_recognizes({<em class="string">"controller"</em> =&gt; <em class="string">"products"</em>, <em class="string">"action"</em> =&gt; <em class="string">"index"</em>},</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="string">"/products"</em>)</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="comment"># And routing with a parameter</em></code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_recognizes({ <em class="string">"controller"</em> =&gt; <em class="string">"line_items"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="string">"action"</em> =&gt; <em class="string">"create"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><em class="string">"product_id"</em> =&gt; <em class="string">"1"</em> },</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{path: <em class="string">"/line_items"</em>, method: :post},</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{<em class="string">"product_id"</em> =&gt; <em class="string">"1"</em>})</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
        </tr>
      </table>

      <p id="N1B118">The <code class="cf ic">path</code> parameter lets you specify routes that are conditional on the HTTP verb of the request. You can test these by passing a hash, rather than a string, as the second parameter to <code class="cf ic">assert_recognizes</code>. The hash should contain two elements: <code class="cf ic">:path</code> will contain the incoming request path, and <code class="cf ic">:method</code> will contain the HTTP verb to be used.</p>

      <p id="N1B127">The <code class="cf ic">extras</code> parameter again contains the additional URL parameters. In the third assertion in the preceding code example, we use the <code class="cf ic">extras</code> parameter to verify that had the URL ended <code class="cf ic">?product_id=1</code>, the resulting <code class="cf ic">params</code> hash would contain the appropriate values.</p>
    </dd>

    <dt class="force-newline"><code class="cf ic">assert_routing(path, options, defaults={}, extras={}, message=nil)</code></dt>

    <dd>
      <p id="N1B13C">Combines the previous two assertions, verifying that the path generates the options and then that the options generate the path.</p>

      <table class="processedcode">
        <tr class="livecodelozenge">
          <td colspan="2"><a href="http://media.pragprog.com/titles/rails4/code/rails31/depot_t/test/unit/routing_test.rb">rails31/depot_t/test/unit/routing_test.rb</a></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">def</strong> test_routing</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_routing(<em class="string">"/"</em>, controller: <em class="string">"store"</em>, action: <em class="string">"index"</em>)</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_routing(<em class="string">"/products"</em>, controller: <em class="string">"products"</em>, action: <em class="string">"index"</em>)</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">assert_routing({path: <em class="string">"/line_items"</em>, method: :post},</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{ controller: <em class="string">"line_items"</em>, action: <em class="string">"create"</em>,</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">product_id: <em class="string">"1"</em>},</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1">{}, { product_id: <em class="string">"1"</em>})</code></td>
        </tr>

        <tr>
          <td class="codeprefix">&nbsp;</td>

          <td class="codeline"><code class="sgc-1"><strong class="prompt">end</strong></code></td>
        </tr>
      </table>
    </dd>
  </dl>

  <p id="N1B18F">It’s important to use symbols as the keys and use strings as the values in the options hash. If you don’t, asserts that compare your options with those returned by routing will fail.</p><script src="../Misc/book_local.js" type="text/javascript">
</script>
</body>
</html>
